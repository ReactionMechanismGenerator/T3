{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Tandem Tool for automated kinetic model generation and refinement Documentation : https://reactionmechanismgenerator.github.io/T3/ Source Code : https://github.com/ReactionMechanismGenerator/T3/ Note T3 is currently under intense development. Features described in these documentation pages which are still not implemented in the code will be marked with an asterisk (*). General \u00b6 T3 is a tool for automatically generating refined kinetic models. The key features are: Convenient : A single universal input file with an equivalent API, controlling all engines. Flexible : Supports all features of RMG and ARC, while maintaining reasonable defaults for simplicity. Structured : All outputs from all iterations are organized in an intuitive folder tree. Easy : Designed to be easy to use and learn. Robust : Captures lower-level exceptions, attempts to troubleshoot. Restartable : Has a convenient restart feature that's being triggered by identifying existing iteration outputs. Principal workflow \u00b6 At it's core, T3 iteratively calls RMG and an automated QM tool (currently supporting only ARC ) to generate a kinetic model and refine it, respectively. The maximal number of iterations along with various control parameters can be determined by the user. Calculated thermodynamic properties and rate coefficients can optionally be uploaded to the community cloud, TCKDB *. T3 also queries TCKDB before instructing the automated QM tool to perform calculations. Intended audience \u00b6 T3 is intended to be used by individuals with prior knowledge in chemical kinetic modeling, and some experience in electronic structure (quantum chemical) calculations. This documentation does not intend to provide advice for which levels of theory should be used for particular systems although examples with specific levels of theory are given. Requirements \u00b6 Python 3.7+ T3 stands on the shoulders of giants: RMG for model generation. ARC for automating electronic structure calculations. License \u00b6 This project is licensed under the terms of the MIT license.","title":"Home"},{"location":"#general","text":"T3 is a tool for automatically generating refined kinetic models. The key features are: Convenient : A single universal input file with an equivalent API, controlling all engines. Flexible : Supports all features of RMG and ARC, while maintaining reasonable defaults for simplicity. Structured : All outputs from all iterations are organized in an intuitive folder tree. Easy : Designed to be easy to use and learn. Robust : Captures lower-level exceptions, attempts to troubleshoot. Restartable : Has a convenient restart feature that's being triggered by identifying existing iteration outputs.","title":"General"},{"location":"#principal-workflow","text":"At it's core, T3 iteratively calls RMG and an automated QM tool (currently supporting only ARC ) to generate a kinetic model and refine it, respectively. The maximal number of iterations along with various control parameters can be determined by the user. Calculated thermodynamic properties and rate coefficients can optionally be uploaded to the community cloud, TCKDB *. T3 also queries TCKDB before instructing the automated QM tool to perform calculations.","title":"Principal workflow"},{"location":"#intended-audience","text":"T3 is intended to be used by individuals with prior knowledge in chemical kinetic modeling, and some experience in electronic structure (quantum chemical) calculations. This documentation does not intend to provide advice for which levels of theory should be used for particular systems although examples with specific levels of theory are given.","title":"Intended audience"},{"location":"#requirements","text":"Python 3.7+ T3 stands on the shoulders of giants: RMG for model generation. ARC for automating electronic structure calculations.","title":"Requirements"},{"location":"#license","text":"This project is licensed under the terms of the MIT license.","title":"License"},{"location":"cite/","text":"How to cite \u00b6 Text form: A. Grinberg Dana, K.A. Spiekermann, W.H. Green, The Tandem Tool (T3) for automated kinetic model generation and refinement, version 0.1.0, source code: https://github.com/ReactionMechanismGenerator/T3 LaTeX form: @misc{T3, author = {A. Grinberg Dana, K.A. Spiekermann, W.H. Green}, title = {The Tandem Tool (T3) for automated kinetic model generation and refinement. https://github.com/ReactionMechanismGenerator/T3, Version 0.1.0}, year = {2020}, howpublished = {\\url{https://github.com/ReactionMechanismGenerator/T3}}, }","title":"How to cite"},{"location":"cite/#how-to-cite","text":"Text form: A. Grinberg Dana, K.A. Spiekermann, W.H. Green, The Tandem Tool (T3) for automated kinetic model generation and refinement, version 0.1.0, source code: https://github.com/ReactionMechanismGenerator/T3 LaTeX form: @misc{T3, author = {A. Grinberg Dana, K.A. Spiekermann, W.H. Green}, title = {The Tandem Tool (T3) for automated kinetic model generation and refinement. https://github.com/ReactionMechanismGenerator/T3, Version 0.1.0}, year = {2020}, howpublished = {\\url{https://github.com/ReactionMechanismGenerator/T3}}, }","title":"How to cite"},{"location":"contribute/","text":"Contribute \u00b6 We use T3 to facilitate our research and have made it available as a benefit to the community in the hopes that others may find it useful as well. We welcome contributions from the community. Please see the contributor guidelines on T3's GitHub page, as well as the Code of Conduct . It is recommended to first open an issue on GitHub, notifying the developers on a bug you are trying to fix or a feature you plan to implement (see our road map ) to avoid duplicate work.","title":"Contribute"},{"location":"contribute/#contribute","text":"We use T3 to facilitate our research and have made it available as a benefit to the community in the hopes that others may find it useful as well. We welcome contributions from the community. Please see the contributor guidelines on T3's GitHub page, as well as the Code of Conduct . It is recommended to first open an issue on GitHub, notifying the developers on a bug you are trying to fix or a feature you plan to implement (see our road map ) to avoid duplicate work.","title":"Contribute"},{"location":"credits/","text":"Credits \u00b6 T3 is developed at the Dana Research Group (Technion) and at the Green Research Group (MIT). T3's contributors are: Dr. Alon Grinberg Dana (leading developer) Kevin Spiekermann","title":"Credits"},{"location":"credits/#credits","text":"T3 is developed at the Dana Research Group (Technion) and at the Green Research Group (MIT). T3's contributors are: Dr. Alon Grinberg Dana (leading developer) Kevin Spiekermann","title":"Credits"},{"location":"how_to/","text":"How to guides \u00b6 Species properties \u00b6 The rmg.species attribute is a list of dictionaries, each defines a chemical species. The following are possible keys and corresponding values for each species dictionary: label (str, required): The species label. concentration (float): concentration units are mole fraction for gas phase and mol/cm3 for liquid phase. Defaults to 0 . smiles (str): The SMILES representation. inchi (str): The InChI representation. adjlist (str): The RMG adjacency list representation. reactive (bool): Whether the species is treated by RMG as reactive. Default: True . observable (bool): Whether the species should be used as an observable for both SA and UA. Default: False. SA_observable (bool): Whether the species should be used as an observable for SA. Default: False. UA_observable (bool): Whether the species should be used as an observable for UA. Default: False. constant (bool): Whether the species concentration should remain constant throughout the simulation and model generation. Default: False. balance (bool): Whether this is a balance species. Default: False. solvent (bool): Whether this species should be used as the solvent in RMG. Can only be set to True for liquid phase simulations. Default: False. xyz (list): Optional 3D coordinates for a species. Entries could be either string representation, ARC dictionary representation, or a file from which the coordinates could be parsed (either an XYZ file format or a supported ESS input/log file). seed_all_rads (List[str]): The types of radical derivatives to add to the RMG input file for the species. Helpful for solving orphan radical issues early on in the model generation. Recommended for the main molecule undergoing oxidation/pyrolysis. Optional types are: 'radical' for simple R., 'alkoxyl' for RO., 'peroxyl' for ROO. Note Either smiles , inchi , or adjlist must be specified for each species. Reactors \u00b6 T3 includes the common RMG reactors. Note that the reactor names have been changed to explicitly represent their primary properties. The supported RMG reactors are: gas batch constant T P which corresponds to the RMG simpleReactor liquid batch constant T V which corresponds to the RMG liquidReactor Note The RMG reactors are only used for model generation. THe simulation is done using the reactor specified in the corresponding simulation adapter which may be different if the simulation adapter is not RMG . Save an input file from the API \u00b6 Saving an input file using the Python documentation may come handy in many cases, since often it is easier to define parameters using Python and auto-complete tools rather than hand-typing a YAML format. To do this, define a T3 object like you would as if running using the API. However, instead of executing it, call write_t3_input_file . Here's an example: from t3 import T3 rmg_args = { 'database' : { 'thermo_libraries' : [ 'primaryThermoLibrary' , 'BurkeH2O2' ], 'kinetics_libraries' : [ 'BurkeH2O2inN2' ]}, 'species' : [{ 'label' : 'H2' , 'smiles' : '[H][H]' , 'concentration' : 0.67 }, { 'label' : 'O2' , 'smiles' : '[O][O]' , 'concentration' : 0.33 }], 'reactors' : [{ 'type' : 'gas batch constant T P' , 'T' : 1000 , 'P' : 1 , 'termination_conversion' : { 'H2' : 0.9 }, 'termination_time' : 1e6 }], 'model' : { 'core_tolerance' : [ 0.01 , 0.001 ]}} t3_object = T3 ( project = 'T3_tutorial_1' , rmg = rmg_args ) t3_object . write_t3_input_file () The corresponding auto-generated YAML input file for the above example would be: project : T3_tutorial_1 rmg : database : kinetics_libraries : - BurkeH2O2inN2 thermo_libraries : - primaryThermoLibrary - BurkeH2O2 model : core_tolerance : - 0.01 - 0.001 reactors : - P : 1.0 T : 1000.0 termination_conversion : H2 : 0.9 termination_time : 1000000.0 type : gas batch constant T P species : - concentration : 0.67 label : H2 smiles : '[H][H]' - concentration : 0.33 label : O2 smiles : '[O][O]' The write_t3_input_file method accepts two arguments: path (str, optional): The full path for the generated input file, or to the folder where this file will be saved under a default name. If ``None``, the input file will be saved to the project directory. all_args (bool, optional): Whether to save all arguments in the generated input file including all default values). Default: ``False``. Writing simulation adapters \u00b6 Coming soon! Pre-QM, or: T3's iteration 0 \u00b6 Sometimes it is desired to conduct thermodynamic and/or rate coefficient calculations in advance, prior to the main T3 iterations. For example, one might want to compute thermodynamic properties for all important radicals of a fuel molecule in advance (before RMG generates a model). This pre-QM computations is called the \"iteration 0\" of T3 and is achieved by specifying species and/or reactions in the QM section of the input. The corresponding computations will be executed, and the computed thermo-kinetic parameters will be used by RMG in all consecutive T3 iterations. The RMG core tolerances \u00b6 RMG uses the toleranceMoveToCore argument to control the size of the generated model (the \"core\"). See detailed explanation here . The corresponding T3 argument is called core_tolerance , and is set under rmg['model'] . This core_tolerance argument is a list of floats, each will be used in a respective T3 iteration. For example, setting core_tolerance = [0.02, 0.01, 0.005, 0.001] will make T3 use a toleranceMoveToCore of 0.02 for running RMG in iteration 1, and a toleranceMoveToCore of 0.001 for running RMG in iteration 4. All iterations further iterations use the last entry in core_tolerance . In the above example, iterations 5, 6, 7... will use a toleranceMoveToCore of 0.001 as well. This feature is useful since at the first iteration RMG is normally executed without system-specific knowledge which is provided as thermodynamic properties and rate coefficients in later T3 iterations. If a RMG is given a too low tolerance in the early iterations it will likely explore unimportant chemistry. By gradually increasing the tolerance we allow RMG to hone in on the model.","title":"How to guides"},{"location":"how_to/#how-to-guides","text":"","title":"How to guides"},{"location":"how_to/#species-properties","text":"The rmg.species attribute is a list of dictionaries, each defines a chemical species. The following are possible keys and corresponding values for each species dictionary: label (str, required): The species label. concentration (float): concentration units are mole fraction for gas phase and mol/cm3 for liquid phase. Defaults to 0 . smiles (str): The SMILES representation. inchi (str): The InChI representation. adjlist (str): The RMG adjacency list representation. reactive (bool): Whether the species is treated by RMG as reactive. Default: True . observable (bool): Whether the species should be used as an observable for both SA and UA. Default: False. SA_observable (bool): Whether the species should be used as an observable for SA. Default: False. UA_observable (bool): Whether the species should be used as an observable for UA. Default: False. constant (bool): Whether the species concentration should remain constant throughout the simulation and model generation. Default: False. balance (bool): Whether this is a balance species. Default: False. solvent (bool): Whether this species should be used as the solvent in RMG. Can only be set to True for liquid phase simulations. Default: False. xyz (list): Optional 3D coordinates for a species. Entries could be either string representation, ARC dictionary representation, or a file from which the coordinates could be parsed (either an XYZ file format or a supported ESS input/log file). seed_all_rads (List[str]): The types of radical derivatives to add to the RMG input file for the species. Helpful for solving orphan radical issues early on in the model generation. Recommended for the main molecule undergoing oxidation/pyrolysis. Optional types are: 'radical' for simple R., 'alkoxyl' for RO., 'peroxyl' for ROO. Note Either smiles , inchi , or adjlist must be specified for each species.","title":"Species properties"},{"location":"how_to/#reactors","text":"T3 includes the common RMG reactors. Note that the reactor names have been changed to explicitly represent their primary properties. The supported RMG reactors are: gas batch constant T P which corresponds to the RMG simpleReactor liquid batch constant T V which corresponds to the RMG liquidReactor Note The RMG reactors are only used for model generation. THe simulation is done using the reactor specified in the corresponding simulation adapter which may be different if the simulation adapter is not RMG .","title":"Reactors"},{"location":"how_to/#save-an-input-file-from-the-api","text":"Saving an input file using the Python documentation may come handy in many cases, since often it is easier to define parameters using Python and auto-complete tools rather than hand-typing a YAML format. To do this, define a T3 object like you would as if running using the API. However, instead of executing it, call write_t3_input_file . Here's an example: from t3 import T3 rmg_args = { 'database' : { 'thermo_libraries' : [ 'primaryThermoLibrary' , 'BurkeH2O2' ], 'kinetics_libraries' : [ 'BurkeH2O2inN2' ]}, 'species' : [{ 'label' : 'H2' , 'smiles' : '[H][H]' , 'concentration' : 0.67 }, { 'label' : 'O2' , 'smiles' : '[O][O]' , 'concentration' : 0.33 }], 'reactors' : [{ 'type' : 'gas batch constant T P' , 'T' : 1000 , 'P' : 1 , 'termination_conversion' : { 'H2' : 0.9 }, 'termination_time' : 1e6 }], 'model' : { 'core_tolerance' : [ 0.01 , 0.001 ]}} t3_object = T3 ( project = 'T3_tutorial_1' , rmg = rmg_args ) t3_object . write_t3_input_file () The corresponding auto-generated YAML input file for the above example would be: project : T3_tutorial_1 rmg : database : kinetics_libraries : - BurkeH2O2inN2 thermo_libraries : - primaryThermoLibrary - BurkeH2O2 model : core_tolerance : - 0.01 - 0.001 reactors : - P : 1.0 T : 1000.0 termination_conversion : H2 : 0.9 termination_time : 1000000.0 type : gas batch constant T P species : - concentration : 0.67 label : H2 smiles : '[H][H]' - concentration : 0.33 label : O2 smiles : '[O][O]' The write_t3_input_file method accepts two arguments: path (str, optional): The full path for the generated input file, or to the folder where this file will be saved under a default name. If ``None``, the input file will be saved to the project directory. all_args (bool, optional): Whether to save all arguments in the generated input file including all default values). Default: ``False``.","title":"Save an input file from the API"},{"location":"how_to/#writing-simulation-adapters","text":"Coming soon!","title":"Writing simulation adapters"},{"location":"how_to/#pre-qm-or-t3s-iteration-0","text":"Sometimes it is desired to conduct thermodynamic and/or rate coefficient calculations in advance, prior to the main T3 iterations. For example, one might want to compute thermodynamic properties for all important radicals of a fuel molecule in advance (before RMG generates a model). This pre-QM computations is called the \"iteration 0\" of T3 and is achieved by specifying species and/or reactions in the QM section of the input. The corresponding computations will be executed, and the computed thermo-kinetic parameters will be used by RMG in all consecutive T3 iterations.","title":"Pre-QM, or: T3's iteration 0"},{"location":"how_to/#the-rmg-core-tolerances","text":"RMG uses the toleranceMoveToCore argument to control the size of the generated model (the \"core\"). See detailed explanation here . The corresponding T3 argument is called core_tolerance , and is set under rmg['model'] . This core_tolerance argument is a list of floats, each will be used in a respective T3 iteration. For example, setting core_tolerance = [0.02, 0.01, 0.005, 0.001] will make T3 use a toleranceMoveToCore of 0.02 for running RMG in iteration 1, and a toleranceMoveToCore of 0.001 for running RMG in iteration 4. All iterations further iterations use the last entry in core_tolerance . In the above example, iterations 5, 6, 7... will use a toleranceMoveToCore of 0.001 as well. This feature is useful since at the first iteration RMG is normally executed without system-specific knowledge which is provided as thermodynamic properties and rate coefficients in later T3 iterations. If a RMG is given a too low tolerance in the early iterations it will likely explore unimportant chemistry. By gradually increasing the tolerance we allow RMG to hone in on the model.","title":"The RMG core tolerances"},{"location":"installation/","text":"Installation \u00b6 Note T3 was only tested on Linux (Ubuntu_ 18.04.1 LTS) and Mac machines. We don't expect it to work on Windows. It can be installed on a server, as well as on your local desktop / laptop, submitting jobs to the server/s. Clone and setup path \u00b6 Download and install the Anaconda Python Platform for Python 3.7 or higher if you haven't already. Get git if you don't have it already by typing sudo apt-get install git in a terminal. Clone T3's repository by typing the following command in the desired folder (e.g., under ~/Code/): $ git clone https://github.com/ReactionMechanismGenerator/T3.git ---> 100% Add T3 to your local path in .bashrc (make sure to change \"~/Path/to/T3/\" accordingly): export PYTHONPATH=$PYTHONPATH:~/Path/to/T3/ Install dependencies \u00b6 Install the latest versions of RMG-Py and the RMG-database on the same machine where T3 is installed. Follow the instructions on RMG's documentation . Make sure to install RMG's developer version which includes important recent features. Be sure to add RMG-Py to your PATH and PYTHONPATH as explained in the instructions. Install the latest version of ARC on the same machine where T3 is installed. Follow the instructions on ARC's documentation . Make sure to add ARC to your PATH and PYTHONPATH, as well as to define your servers as explained in ARC's documentation. Create the Anaconda environment for T3 by executing the following command in the T3 folder: $ conda env create -f environment.yml INFO: Collecting package metadata (repodata.json): done INFO: Solving environment: done INFO: INFO: Downloading and Extracting Packages INFO: ... INFO: Preparing transaction: done INFO: Verifying transaction: done INFO: Executing transaction: done INFO: # INFO: # To activate this environment, use INFO: # INFO: # $ conda activate t3_env INFO: # INFO: # To deactivate an active environment, use INFO: # INFO: # $ conda deactivate Activate the T3 environment every time before running T3: conda activate t3_env Add T3 aliases to your .bashrc \u00b6 Some optional yet convenient aliases are listed below (make sure to change \"/Path/to/T3/\" accordingly). Add these to your .bashrc file, which can be edited by typing, e.g., nano ~./bashrc : export t3_path=$HOME`/Path/to/T3' alias t3e='source activate t3_env' alias t3='python $t3_path/T3.py input.yml' alias t3code='cd $t3_path' Then, after sourcing .bashrc or restarting the terminal, simply typing t3e will activate the environment, typing t3code will change the directory into the T3 repository, and finally typing t3 from any folder with a valid T3 input file will execute T3 in that folder. Updating T3 \u00b6 The T3 repository is being updated frequently. Make sure to update your instance of T3 to enjoy new features and get recent bug fixes. To get the most recent developer version, execute the following commands (make sure to change ~/Path/to/T3/ accordingly): cd ~/Path/to/T3/ git fetch origin git pull origin master The above will update your master branch of T3.","title":"Installation"},{"location":"installation/#installation","text":"Note T3 was only tested on Linux (Ubuntu_ 18.04.1 LTS) and Mac machines. We don't expect it to work on Windows. It can be installed on a server, as well as on your local desktop / laptop, submitting jobs to the server/s.","title":"Installation"},{"location":"installation/#clone-and-setup-path","text":"Download and install the Anaconda Python Platform for Python 3.7 or higher if you haven't already. Get git if you don't have it already by typing sudo apt-get install git in a terminal. Clone T3's repository by typing the following command in the desired folder (e.g., under ~/Code/): $ git clone https://github.com/ReactionMechanismGenerator/T3.git ---> 100% Add T3 to your local path in .bashrc (make sure to change \"~/Path/to/T3/\" accordingly): export PYTHONPATH=$PYTHONPATH:~/Path/to/T3/","title":"Clone and setup path"},{"location":"installation/#install-dependencies","text":"Install the latest versions of RMG-Py and the RMG-database on the same machine where T3 is installed. Follow the instructions on RMG's documentation . Make sure to install RMG's developer version which includes important recent features. Be sure to add RMG-Py to your PATH and PYTHONPATH as explained in the instructions. Install the latest version of ARC on the same machine where T3 is installed. Follow the instructions on ARC's documentation . Make sure to add ARC to your PATH and PYTHONPATH, as well as to define your servers as explained in ARC's documentation. Create the Anaconda environment for T3 by executing the following command in the T3 folder: $ conda env create -f environment.yml INFO: Collecting package metadata (repodata.json): done INFO: Solving environment: done INFO: INFO: Downloading and Extracting Packages INFO: ... INFO: Preparing transaction: done INFO: Verifying transaction: done INFO: Executing transaction: done INFO: # INFO: # To activate this environment, use INFO: # INFO: # $ conda activate t3_env INFO: # INFO: # To deactivate an active environment, use INFO: # INFO: # $ conda deactivate Activate the T3 environment every time before running T3: conda activate t3_env","title":"Install dependencies"},{"location":"installation/#add-t3-aliases-to-your-bashrc","text":"Some optional yet convenient aliases are listed below (make sure to change \"/Path/to/T3/\" accordingly). Add these to your .bashrc file, which can be edited by typing, e.g., nano ~./bashrc : export t3_path=$HOME`/Path/to/T3' alias t3e='source activate t3_env' alias t3='python $t3_path/T3.py input.yml' alias t3code='cd $t3_path' Then, after sourcing .bashrc or restarting the terminal, simply typing t3e will activate the environment, typing t3code will change the directory into the T3 repository, and finally typing t3 from any folder with a valid T3 input file will execute T3 in that folder.","title":"Add T3 aliases to your .bashrc"},{"location":"installation/#updating-t3","text":"The T3 repository is being updated frequently. Make sure to update your instance of T3 to enjoy new features and get recent bug fixes. To get the most recent developer version, execute the following commands (make sure to change ~/Path/to/T3/ accordingly): cd ~/Path/to/T3/ git fetch origin git pull origin master The above will update your master branch of T3.","title":"Updating T3"},{"location":"licence/","text":"Licence \u00b6 T3 is distributed free of charge under the MIT license. MIT License Copyright (c) 2019-2020 Dana Research Group Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Licence"},{"location":"licence/#licence","text":"T3 is distributed free of charge under the MIT license. MIT License Copyright (c) 2019-2020 Dana Research Group Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Licence"},{"location":"output/","text":"Output \u00b6 After running a Project, the local Project folder will contain the following directory tree ( bold represents folders, italics represents files): t3.log : Details of all project execution procedures. iteration_x : RMG : input.py : The RMG input file for iteration x (automatically written by T3) RMG.log : The RMG log file for iteration x. Additional RMG files and folders ARC : restart.yml : The ARC restart file for iteration x. arc.log : The ARC log file for iteration x. calcs : All spawned jobs sorted by species name (including transition states). output : Additional ARC output files and folders.","title":"Output"},{"location":"output/#output","text":"After running a Project, the local Project folder will contain the following directory tree ( bold represents folders, italics represents files): t3.log : Details of all project execution procedures. iteration_x : RMG : input.py : The RMG input file for iteration x (automatically written by T3) RMG.log : The RMG log file for iteration x. Additional RMG files and folders ARC : restart.yml : The ARC restart file for iteration x. arc.log : The ARC log file for iteration x. calcs : All spawned jobs sorted by species name (including transition states). output : Additional ARC output files and folders.","title":"Output"},{"location":"release/","text":"Release notes \u00b6 T3 0.1.0 \u00b6 This is the first version of T3. Version style \u00b6 T3 uses Semantic Versioning","title":"Release notes"},{"location":"release/#release-notes","text":"","title":"Release notes"},{"location":"release/#t3-010","text":"This is the first version of T3.","title":"T3 0.1.0"},{"location":"release/#version-style","text":"T3 uses Semantic Versioning","title":"Version style"},{"location":"running/","text":"Running T3 \u00b6 General \u00b6 Executing T3 can be done via two ways: using an input file, or using the Python API Other than subtle differences described here, both approaches are equivalent as they can define the same parameters which will be processed via the same routines. Note Most examples in these documentation pages are in a Python API format rather than a YAML input file format. T3 also has a function for writing a corresponding YAML input file after defining parameters via the API, see the How-to guides for more details. Activate the environment \u00b6 To use T3, first activate the T3 environment. Type either: conda activate t3_env or, if you have set up the recommended aliases, simply type: t3e Arguments \u00b6 T3 has three minor arguments ( project , project_directory , and verbose ) and three primary arguments ( t3 , rmg , and qm ). The project argument is required. It is a string representing the T3 project name. The project_directory argument is optional. It is a string representing the path to the local project directory where all the project files are stored. If not specified, it will be set to the folder in which the input file is located if T3 is being executed using an input file, or to a respective subfolder with the project's name under the Projects folder in the T3 repository. The verbose argument is optional. It is an integer representing the logging level used by T3. Allowed values are: 10 : debug level (very verbose), 20 : info level (default), 30 : warnings and errors only, 40 : errors only. Pass None to this argument to avoid saving a log file. The primary arguments specify various options for the different respective packages (T3, RMG, and QM which currently only supports ARC ). Of these three, only the rmg argument is required. The qm argument must be specified if QM-based model refinement is desired (in most cases it is!). The t3 argument contains optional T3-related directives and should commonly be specified. The RMG arguments in T3 are written in an underscore_lower_case (snake_case) syntax, while many are in a camelCase syntax in RMG. A few RMG arguments have different names altogether in T3. These arguments are: kinetics_libraries : In the RMG database block, the kinetics_libraries argument replaces the legacy RMG reactionLibraries argument. core_tolerance : In the RMG model block, the core_tolerance argument replaces the legacy RMG toleranceMoveToCore argument. See the How-to guides for more details. conditions_per_iteration : In the RMG reactors block, the conditions_per_iteration argument replaces the legacy RMG nSims argument. Species definitions are different than in RMG, see the How-to guides for more details. Reactors definitions are different than in RMG, see the How-to guides for more details. Note Some of the RMG default values have been changed in T3, see the schema for details. Use the below reference guide to learn more about these arguments. Reference guide \u00b6 T3 has several types of reference guides: The tutorials are a great place to start with, and provide an excellent basic reference guide. In T3's tutorials you can find complete, functioning, and worked-out examples with explanations. The commented input file in T3's examples shows all available input arguments along with a brief explanation. A pydentic schema is used to validate the input file, and could also be used as a reference for the various allowed arguments. Where next? \u00b6 New users should start learning how to use T3 by reading and executing the tutorials . For advanced features and specific examples for solving complex problems, see the how-to guides .","title":"Running T3"},{"location":"running/#running-t3","text":"","title":"Running T3"},{"location":"running/#general","text":"Executing T3 can be done via two ways: using an input file, or using the Python API Other than subtle differences described here, both approaches are equivalent as they can define the same parameters which will be processed via the same routines. Note Most examples in these documentation pages are in a Python API format rather than a YAML input file format. T3 also has a function for writing a corresponding YAML input file after defining parameters via the API, see the How-to guides for more details.","title":"General"},{"location":"running/#activate-the-environment","text":"To use T3, first activate the T3 environment. Type either: conda activate t3_env or, if you have set up the recommended aliases, simply type: t3e","title":"Activate the environment"},{"location":"running/#arguments","text":"T3 has three minor arguments ( project , project_directory , and verbose ) and three primary arguments ( t3 , rmg , and qm ). The project argument is required. It is a string representing the T3 project name. The project_directory argument is optional. It is a string representing the path to the local project directory where all the project files are stored. If not specified, it will be set to the folder in which the input file is located if T3 is being executed using an input file, or to a respective subfolder with the project's name under the Projects folder in the T3 repository. The verbose argument is optional. It is an integer representing the logging level used by T3. Allowed values are: 10 : debug level (very verbose), 20 : info level (default), 30 : warnings and errors only, 40 : errors only. Pass None to this argument to avoid saving a log file. The primary arguments specify various options for the different respective packages (T3, RMG, and QM which currently only supports ARC ). Of these three, only the rmg argument is required. The qm argument must be specified if QM-based model refinement is desired (in most cases it is!). The t3 argument contains optional T3-related directives and should commonly be specified. The RMG arguments in T3 are written in an underscore_lower_case (snake_case) syntax, while many are in a camelCase syntax in RMG. A few RMG arguments have different names altogether in T3. These arguments are: kinetics_libraries : In the RMG database block, the kinetics_libraries argument replaces the legacy RMG reactionLibraries argument. core_tolerance : In the RMG model block, the core_tolerance argument replaces the legacy RMG toleranceMoveToCore argument. See the How-to guides for more details. conditions_per_iteration : In the RMG reactors block, the conditions_per_iteration argument replaces the legacy RMG nSims argument. Species definitions are different than in RMG, see the How-to guides for more details. Reactors definitions are different than in RMG, see the How-to guides for more details. Note Some of the RMG default values have been changed in T3, see the schema for details. Use the below reference guide to learn more about these arguments.","title":"Arguments"},{"location":"running/#reference-guide","text":"T3 has several types of reference guides: The tutorials are a great place to start with, and provide an excellent basic reference guide. In T3's tutorials you can find complete, functioning, and worked-out examples with explanations. The commented input file in T3's examples shows all available input arguments along with a brief explanation. A pydentic schema is used to validate the input file, and could also be used as a reference for the various allowed arguments.","title":"Reference guide"},{"location":"running/#where-next","text":"New users should start learning how to use T3 by reading and executing the tutorials . For advanced features and specific examples for solving complex problems, see the how-to guides .","title":"Where next?"},{"location":"tutorials/1_no_qm/","text":"1. Simple system, no QM \u00b6 This tutorial will guide you through setting up T3 to generate a detailed kinetic model for a relatively simple system, a H 2 /O 2 flame. The model will consist of species and reactions for which thermodynamic properties and rate coefficients, respectively, are already known from the literature. It is an exercise in setting up T3 for a system for which no quantum mechanical (QM) calculations are executed. When using the API, the first directive is to import the main T3 object (this is not needed when using an input file): from t3 import T3 rmg_args = { 'database' : { 'thermo_libraries' : [ 'primaryThermoLibrary' , 'BurkeH2O2' ], 'kinetics_libraries' : [ 'BurkeH2O2inN2' ]}, 'species' : [{ 'label' : 'H2' , 'smiles' : '[H][H]' , 'concentration' : 0.67 }, { 'label' : 'O2' , 'smiles' : '[O][O]' , 'concentration' : 0.33 }], 'reactors' : [{ 'type' : 'gas batch constant T P' , 'T' : 1000 , 'P' : 1 , 'termination_conversion' : { 'H2' : 0.9 }, 'termination_time' : 1e6 }], 'model' : { 'core_tolerance' : [ 0.01 , 0.001 ]}} t3_object = T3 ( project = 'T3_tutorial_1' , rmg = rmg_args ) t3_object . execute () (This script is complete, it should run \"as is\") Next we'll define arguments related to RMG. This argument is a Python dictionary which will be passed to the rmg argument of the T3 object imported above. You can name this argument with any legal Python name, here we use rmg_args . This is the only required primary argument -- this simple example does not make use of the additional primary arguments, t3 and qm . from t3 import T3 rmg_args = { 'database' : { 'thermo_libraries' : [ 'primaryThermoLibrary' , 'BurkeH2O2' ], 'kinetics_libraries' : [ 'BurkeH2O2inN2' ]}, 'species' : [{ 'label' : 'H2' , 'smiles' : '[H][H]' , 'concentration' : 0.67 }, { 'label' : 'O2' , 'smiles' : '[O][O]' , 'concentration' : 0.33 }], 'reactors' : [{ 'type' : 'gas batch constant T P' , 'T' : 1000 , 'P' : 1 , 'termination_conversion' : { 'H2' : 0.9 }, 'termination_time' : 1e6 }], 'model' : { 'core_tolerance' : [ 0.01 , 0.001 ]}} t3_object = T3 ( project = 'T3_tutorial_1' , rmg = rmg_args ) t3_object . execute () Here, the rmg_args argument defines the database libraries to be used by RMG, the chemical species with respective structure and concentration, the reactor type, conditions and termination criteria, and the RMG core tolerances to be used throughout the different T3 iterations. Note The RMG arguments in T3 generally correspond to arguments used by the legacy RMG input file. Users should refer to the RMG documentation for detailed explanations of all possible arguments. This tutorial, though, manages to capture all major syntax differences users should be aware of when defining the RMG arguments in T3: RMG arguments are currently in camelCase style (e.g., thermoLibraries ), whereas the respective arguments in T3 are in lower_case_underscore style (e.g., thermo_libraries ). Species definitions in T3 are more flexible, see the how-to guides for more details. Reactor types were re-named for clarity, see the how-to guides for more details. core_tolerance is a list of the RMG toleranceMoveToCore argument to use per T3 iteration. If the number of iterations is larger than the length of core_tolerance , the last entry will be used. The `core_tolerance`` argument can also be given as flot, in which case it will be treated as a onc-entry list. Minor: RMG uses the notation reactionLibraries while T3 uses kinetics_libraries . Next, we create the T3 object with all desired arguments. Here, only the two required arguments, project and rmg are given. from t3 import T3 rmg_args = { 'database' : { 'thermo_libraries' : [ 'primaryThermoLibrary' , 'BurkeH2O2' ], 'kinetics_libraries' : [ 'BurkeH2O2inN2' ]}, 'species' : [{ 'label' : 'H2' , 'smiles' : '[H][H]' , 'concentration' : 0.67 }, { 'label' : 'O2' , 'smiles' : '[O][O]' , 'concentration' : 0.33 }], 'reactors' : [{ 'type' : 'gas batch constant T P' , 'T' : 1000 , 'P' : 1 , 'termination_conversion' : { 'H2' : 0.9 }, 'termination_time' : 1e6 }], 'model' : { 'core_tolerance' : [ 0.01 , 0.001 ]}} t3_object = T3 ( project = 'T3_tutorial_1' , rmg = rmg_args ) t3_object . execute () Finally, we call the execute() method of T3 . from t3 import T3 rmg_args = { 'database' : { 'thermo_libraries' : [ 'primaryThermoLibrary' , 'BurkeH2O2' ], 'kinetics_libraries' : [ 'BurkeH2O2inN2' ]}, 'species' : [{ 'label' : 'H2' , 'smiles' : '[H][H]' , 'concentration' : 0.67 }, { 'label' : 'O2' , 'smiles' : '[O][O]' , 'concentration' : 0.33 }], 'reactors' : [{ 'type' : 'gas batch constant T P' , 'T' : 1000 , 'P' : 1 , 'termination_conversion' : { 'H2' : 0.9 }, 'termination_time' : 1e6 }], 'model' : { 'core_tolerance' : [ 0.01 , 0.001 ]}} t3_object = T3 ( project = 'T3_tutorial_1' , rmg = rmg_args ) t3_object . execute () Note that the corresponding YAML input file for this tutorial would be: project : T3_tutorial_1 rmg : database : kinetics_libraries : - BurkeH2O2inN2 thermo_libraries : - primaryThermoLibrary - BurkeH2O2 model : core_tolerance : - 0.01 - 0.001 reactors : - P : 1.0 T : 1000.0 termination_conversion : H2 : 0.9 termination_time : 1000000.0 type : gas batch constant T P species : - concentration : 0.67 label : H2 smiles : '[H][H]' - concentration : 0.33 label : O2 smiles : '[O][O]'","title":"1. Simple system, no QM"},{"location":"tutorials/1_no_qm/#1-simple-system-no-qm","text":"This tutorial will guide you through setting up T3 to generate a detailed kinetic model for a relatively simple system, a H 2 /O 2 flame. The model will consist of species and reactions for which thermodynamic properties and rate coefficients, respectively, are already known from the literature. It is an exercise in setting up T3 for a system for which no quantum mechanical (QM) calculations are executed. When using the API, the first directive is to import the main T3 object (this is not needed when using an input file): from t3 import T3 rmg_args = { 'database' : { 'thermo_libraries' : [ 'primaryThermoLibrary' , 'BurkeH2O2' ], 'kinetics_libraries' : [ 'BurkeH2O2inN2' ]}, 'species' : [{ 'label' : 'H2' , 'smiles' : '[H][H]' , 'concentration' : 0.67 }, { 'label' : 'O2' , 'smiles' : '[O][O]' , 'concentration' : 0.33 }], 'reactors' : [{ 'type' : 'gas batch constant T P' , 'T' : 1000 , 'P' : 1 , 'termination_conversion' : { 'H2' : 0.9 }, 'termination_time' : 1e6 }], 'model' : { 'core_tolerance' : [ 0.01 , 0.001 ]}} t3_object = T3 ( project = 'T3_tutorial_1' , rmg = rmg_args ) t3_object . execute () (This script is complete, it should run \"as is\") Next we'll define arguments related to RMG. This argument is a Python dictionary which will be passed to the rmg argument of the T3 object imported above. You can name this argument with any legal Python name, here we use rmg_args . This is the only required primary argument -- this simple example does not make use of the additional primary arguments, t3 and qm . from t3 import T3 rmg_args = { 'database' : { 'thermo_libraries' : [ 'primaryThermoLibrary' , 'BurkeH2O2' ], 'kinetics_libraries' : [ 'BurkeH2O2inN2' ]}, 'species' : [{ 'label' : 'H2' , 'smiles' : '[H][H]' , 'concentration' : 0.67 }, { 'label' : 'O2' , 'smiles' : '[O][O]' , 'concentration' : 0.33 }], 'reactors' : [{ 'type' : 'gas batch constant T P' , 'T' : 1000 , 'P' : 1 , 'termination_conversion' : { 'H2' : 0.9 }, 'termination_time' : 1e6 }], 'model' : { 'core_tolerance' : [ 0.01 , 0.001 ]}} t3_object = T3 ( project = 'T3_tutorial_1' , rmg = rmg_args ) t3_object . execute () Here, the rmg_args argument defines the database libraries to be used by RMG, the chemical species with respective structure and concentration, the reactor type, conditions and termination criteria, and the RMG core tolerances to be used throughout the different T3 iterations. Note The RMG arguments in T3 generally correspond to arguments used by the legacy RMG input file. Users should refer to the RMG documentation for detailed explanations of all possible arguments. This tutorial, though, manages to capture all major syntax differences users should be aware of when defining the RMG arguments in T3: RMG arguments are currently in camelCase style (e.g., thermoLibraries ), whereas the respective arguments in T3 are in lower_case_underscore style (e.g., thermo_libraries ). Species definitions in T3 are more flexible, see the how-to guides for more details. Reactor types were re-named for clarity, see the how-to guides for more details. core_tolerance is a list of the RMG toleranceMoveToCore argument to use per T3 iteration. If the number of iterations is larger than the length of core_tolerance , the last entry will be used. The `core_tolerance`` argument can also be given as flot, in which case it will be treated as a onc-entry list. Minor: RMG uses the notation reactionLibraries while T3 uses kinetics_libraries . Next, we create the T3 object with all desired arguments. Here, only the two required arguments, project and rmg are given. from t3 import T3 rmg_args = { 'database' : { 'thermo_libraries' : [ 'primaryThermoLibrary' , 'BurkeH2O2' ], 'kinetics_libraries' : [ 'BurkeH2O2inN2' ]}, 'species' : [{ 'label' : 'H2' , 'smiles' : '[H][H]' , 'concentration' : 0.67 }, { 'label' : 'O2' , 'smiles' : '[O][O]' , 'concentration' : 0.33 }], 'reactors' : [{ 'type' : 'gas batch constant T P' , 'T' : 1000 , 'P' : 1 , 'termination_conversion' : { 'H2' : 0.9 }, 'termination_time' : 1e6 }], 'model' : { 'core_tolerance' : [ 0.01 , 0.001 ]}} t3_object = T3 ( project = 'T3_tutorial_1' , rmg = rmg_args ) t3_object . execute () Finally, we call the execute() method of T3 . from t3 import T3 rmg_args = { 'database' : { 'thermo_libraries' : [ 'primaryThermoLibrary' , 'BurkeH2O2' ], 'kinetics_libraries' : [ 'BurkeH2O2inN2' ]}, 'species' : [{ 'label' : 'H2' , 'smiles' : '[H][H]' , 'concentration' : 0.67 }, { 'label' : 'O2' , 'smiles' : '[O][O]' , 'concentration' : 0.33 }], 'reactors' : [{ 'type' : 'gas batch constant T P' , 'T' : 1000 , 'P' : 1 , 'termination_conversion' : { 'H2' : 0.9 }, 'termination_time' : 1e6 }], 'model' : { 'core_tolerance' : [ 0.01 , 0.001 ]}} t3_object = T3 ( project = 'T3_tutorial_1' , rmg = rmg_args ) t3_object . execute () Note that the corresponding YAML input file for this tutorial would be: project : T3_tutorial_1 rmg : database : kinetics_libraries : - BurkeH2O2inN2 thermo_libraries : - primaryThermoLibrary - BurkeH2O2 model : core_tolerance : - 0.01 - 0.001 reactors : - P : 1.0 T : 1000.0 termination_conversion : H2 : 0.9 termination_time : 1000000.0 type : gas batch constant T P species : - concentration : 0.67 label : H2 smiles : '[H][H]' - concentration : 0.33 label : O2 smiles : '[O][O]'","title":"1. Simple system, no QM"}]}