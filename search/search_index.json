{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p> The Tandem Tool for automated kinetic model generation and refinement </p> <p> </p> <p>Documentation:  https://reactionmechanismgenerator.github.io/T3/</p> <p>Source Code:  https://github.com/ReactionMechanismGenerator/T3/</p> <p>Note</p> <p>T3 is currently under intense development. Features described in these documentation pages which are still not implemented in the code will be marked with an asterisk (*).</p>"},{"location":"#general","title":"General","text":"<p>T3 is a tool for automatically generating refined kinetic models.</p> <p>The key features are:</p> <ul> <li>Convenient: A single universal input file with an equivalent API,   controlling all engines.</li> <li>Flexible: Supports all features of RMG and ARC, while maintaining   reasonable defaults for simplicity.</li> <li>Structured: All outputs from all iterations are organized in an   intuitive folder tree.</li> <li>Easy: Designed to be easy to use and learn.</li> <li>Robust: Captures lower-level exceptions, attempts to troubleshoot.</li> <li>Restartable: Has a convenient restart feature that's being triggered   by identifying existing iteration outputs. </li> </ul>"},{"location":"#principal-workflow","title":"Principal workflow","text":"<p>At it's core, T3 iteratively calls RMG and an automated QM tool (currently supporting only ARC) to generate a kinetic model and refine it, respectively. The maximal number of iterations along with various control parameters can be determined by the user. Calculated thermodynamic properties and rate coefficients can optionally be uploaded to the community cloud, TCKDB*. T3 also queries TCKDB before instructing the automated QM tool to perform calculations.</p>"},{"location":"#intended-audience","title":"Intended audience","text":"<p>T3 is intended to be used by individuals with prior knowledge in chemical kinetic modeling, and some experience in electronic structure (quantum chemical) calculations. This documentation does not intend to provide advice for which levels of theory should be used for particular systems although examples with specific levels of theory are given.</p>"},{"location":"#requirements","title":"Requirements","text":"<p>Python 3.7+</p> <p>T3 stands on the shoulders of giants:</p> <ul> <li>RMG for model generation.</li> <li>ARC for automating electronic structure calculations.</li> </ul>"},{"location":"#license","title":"License","text":"<p>This project is licensed under the terms of the MIT license.</p>"},{"location":"cite/","title":"How to cite","text":"<p>Text form:</p> <pre><code>A. Grinberg Dana, K.A. Spiekermann, W.H. Green, \nThe Tandem Tool (T3) for automated kinetic model generation and refinement, \nversion 0.1.0, source code: https://github.com/ReactionMechanismGenerator/T3\n</code></pre> <p>LaTeX form:</p> <pre><code>@misc{T3,\n  author = {A. Grinberg Dana, K.A. Spiekermann, W.H. Green},\n  title = {The Tandem Tool (T3) for automated kinetic model generation and refinement. https://github.com/ReactionMechanismGenerator/T3, Version 0.1.0},\n  year = {2020},\n  howpublished = {\\url{https://github.com/ReactionMechanismGenerator/T3}},\n}\n</code></pre>"},{"location":"contribute/","title":"Contribute","text":"<p>We use T3 to facilitate our research and have made it available as a benefit to the community in the hopes that others may find it useful as well.</p> <p>We welcome contributions from the community. Please see the  contributor guidelines on T3's GitHub page, as well as the  Code of Conduct.</p> <p>It is recommended to first open an issue on GitHub, notifying the developers on a bug you are trying to fix or a feature you plan to implement (see our road map) to avoid duplicate work.</p>"},{"location":"credits/","title":"Credits","text":"<p>T3 is developed at the Dana Research Group (Technion) and at the Green Research Group (MIT).</p> <p>T3's contributors are:</p> <ul> <li>Dr. Alon Grinberg Dana (leading developer)</li> <li>Kevin Spiekermann</li> </ul>"},{"location":"how_to/","title":"How to guides","text":""},{"location":"how_to/#species-properties","title":"Species properties","text":"<p>The <code>rmg.species</code> attribute is a list of dictionaries, each defines a chemical species. The following are possible keys and corresponding values for each species dictionary:</p> <ul> <li><code>label</code> (str, required): The species label.</li> <li><code>concentration</code> (Union[float, Tuple[float, float]]): Concentration units are mole fraction for gas phase   and mol/cm3 for liquid phase. Defaults to <code>0</code>.   A concentration range can also be specified (a length-2 tuple).</li> <li><code>smiles</code> (str): The      SMILES representation.</li> <li><code>inchi</code> (str): The      InChI representation.</li> <li><code>adjlist</code> (str): The      RMG adjacency list representation.</li> <li><code>reactive</code> (bool): Whether the species is treated by RMG as reactive. Default: <code>True</code>.</li> <li><code>observable</code> (bool): Whether the species should be used as an observable for both SA and UA. Default: <code>False.</code></li> <li><code>SA_observable</code> (bool): Whether the species should be used as an observable for SA. Default: <code>False.</code></li> <li><code>UA_observable</code> (bool): Whether the species should be used as an observable for UA. Default: <code>False.</code></li> <li><code>constant</code> (bool): Whether the species concentration should remain constant throughout the simulation   and model generation. Default: <code>False.</code></li> <li><code>balance</code> (bool): Whether this is a balance species. Default: <code>False.</code></li> <li><code>solvent</code> (bool): Whether this species should be used as the solvent in RMG. Can only be set to <code>True</code>   for liquid phase simulations. Default: <code>False.</code></li> <li><code>xyz</code> (list): Optional 3D coordinates for a species. Entries could be either string representation,   ARC dictionary representation, or a file from which the coordinates could be parsed   (either an   XYZ file format   or a supported ESS input/log file).</li> <li><code>seed_all_rads</code> (List[str]): The types of radical derivatives to add to the RMG input file   for the species. Helpful for solving orphan radical issues early on in the model generation.   Recommended for the main molecule undergoing oxidation/pyrolysis.   Optional types are: 'radical' for simple R., 'alkoxyl' for RO., 'peroxyl' for ROO.</li> </ul> <p>Note</p> <p>Either <code>smiles</code>, <code>inchi</code>, or <code>adjlist</code> must be specified for each species.</p>"},{"location":"how_to/#reactors","title":"Reactors","text":"<p>T3 includes the common RMG reactors. Note that the reactor names have been changed to explicitly represent their primary properties. The supported RMG reactors are:</p> <ul> <li><code>gas batch constant T P</code> which corresponds to the RMG <code>simpleReactor</code></li> <li><code>liquid batch constant T V</code> which corresponds to the RMG <code>liquidReactor</code></li> </ul> <p>Note</p> <p>The RMG reactors are only used for model generation. THe simulation is done using the reactor specified in the corresponding simulation adapter which may be different if the simulation adapter is not <code>RMG</code>.</p>"},{"location":"how_to/#save-an-input-file-from-the-api","title":"Save an input file from the API","text":"<p>Saving an input file using the Python documentation may come handy in many cases, since often it is easier to define parameters using Python and auto-complete tools rather than hand-typing a YAML format.</p> <p>To do this, define a <code>T3</code> object like you would as if running using the API. However, instead of executing it, call <code>write_t3_input_file</code>. Here's an example:</p> <pre><code>from t3 import T3\n\nrmg_args = {'database': {'thermo_libraries': ['primaryThermoLibrary',\n                                              'BurkeH2O2'],\n                         'kinetics_libraries': ['BurkeH2O2inN2']},\n            'species': [{'label': 'H2',\n                         'smiles': '[H][H]',\n                         'concentration': 0.67},\n                        {'label': 'O2',\n                         'smiles': '[O][O]',\n                         'concentration': 0.33}],\n            'reactors': [{'type': 'gas batch constant T P',\n                          'T': 1000,\n                          'P': 1,\n                          'termination_conversion': {'H2': 0.9},\n                          'termination_time': [5, 's']}],\n            'model': {'core_tolerance': [0.01, 0.001]}}\n\nt3_object = T3(project='T3_tutorial_1',\n               rmg=rmg_args)\n\nt3_object.write_t3_input_file()\n</code></pre> <p>The corresponding auto-generated YAML input file for the above example would be:</p> <pre><code>project: T3_tutorial_1\nrmg:\ndatabase:\nkinetics_libraries:\n- BurkeH2O2inN2\nthermo_libraries:\n- primaryThermoLibrary\n- BurkeH2O2\nmodel:\ncore_tolerance:\n- 0.01\n- 0.001\nreactors:\n- P: 1.0\nT: 1000.0\ntermination_conversion:\nH2: 0.9\ntermination_time:\n- 5\n- 's'\ntype: gas batch constant T P\nspecies:\n- concentration: 0.67\nlabel: H2\nsmiles: '[H][H]'\n- concentration: 0.33\nlabel: O2\nsmiles: '[O][O]'\n</code></pre> <p>The <code>write_t3_input_file</code> method accepts two arguments:</p> <p>path (str, optional):</p> <pre><code>The full path for the generated input file, or to the folder\nwhere this file will be saved under a default name.\nIf ``None``, the input file will be saved to the project directory.\n</code></pre> <p>all_args (bool, optional):</p> <pre><code>Whether to save all arguments in the generated input file\nincluding all default values). Default: ``False``.\n</code></pre>"},{"location":"how_to/#writing-simulation-adapters","title":"Writing simulation adapters","text":"<p>T3 implements many common choices to simulate a chemical mechanism, such as using constant TP, UV, or HP batch reactors. To create a custom simulator for your needs, first add a new file to <code>T3/t3/simulate/</code>, which contains the new simulate adapter. The new class must inherit from the abstract adapter class in <code>T3/t3/simulate/adapter.py</code> and should implement the following methods: <code>set_up()</code>, <code>simulate()</code>, <code>get_sa_coefficients()</code>, and <code>get_idt_by_T()</code>. All simulate adapters must accept the same arguments; the currently implemented Cantera, RMG, and RMS adapters provide examples. Finally, register the adapter at the bottom of the file, and initialize the simulator by importing it in <code>T3/t3/simulate/__init__.py</code>. A more detailed coding example can be found in the tutorials section. Adding a test to <code>T3/tests/test_simulate_adapters/</code> is also recommended. We welcome pull-requests to incorporate new simulate adapters.</p>"},{"location":"how_to/#pre-qm-or-t3s-iteration-0","title":"Pre-QM, or: T3's iteration 0","text":"<p>Sometimes it is desired to conduct thermodynamic and/or rate coefficient calculations in advance, prior to the main T3 iterations. For example, one might want to compute thermodynamic properties for all important radicals of a fuel molecule in advance (before RMG generates a model).</p> <p>This pre-QM computations is called the \"iteration 0\" of T3 and is achieved by specifying <code>species</code> and/or <code>reactions</code> in the QM section of the input. The corresponding computations will be executed, and the computed thermo-kinetic parameters will be used by RMG in all consecutive T3 iterations.</p>"},{"location":"how_to/#the-rmg-core-tolerances","title":"The RMG core tolerances","text":"<p>RMG uses the <code>toleranceMoveToCore</code> argument to control the size of the generated model (the \"core\"). See detailed explanation  here. The corresponding T3 argument is called <code>core_tolerance</code>, and is set under <code>rmg['model']</code>. This <code>core_tolerance</code> argument is a list of floats, each will be used in a respective T3 iteration. For example, setting <code>core_tolerance = [0.02, 0.01, 0.005, 0.001]</code> will make T3 use a <code>toleranceMoveToCore</code> of <code>0.02</code> for running RMG in iteration 1, and a <code>toleranceMoveToCore</code> of <code>0.001</code> for running RMG in iteration 4. All iterations further iterations use the last entry in <code>core_tolerance</code>. In the above example, iterations 5, 6, 7... will use a <code>toleranceMoveToCore</code> of <code>0.001</code> as well.</p> <p>This feature is useful since at the first iteration RMG is normally executed without system-specific knowledge which is provided as thermodynamic properties and rate coefficients in later T3 iterations. If a RMG is given a too low tolerance in the early iterations it will likely explore unimportant chemistry. By gradually increasing the tolerance we allow RMG to hone in on the model.</p>"},{"location":"installation/","title":"Installation","text":"<p>T3 was only tested on Linux (Ubuntu_ 22.04.1 LTS) and MacOS. We don't expect it to work on Windows.</p> <p>It can be installed on a server, as well as on your local desktop / laptop, in order to submit jobs to the server/s.</p>"},{"location":"installation/#package-manager-and-cloning-from-github","title":"Package Manager and Cloning from Github","text":""},{"location":"installation/#unix-like-platforms","title":"Unix-like platforms","text":"<ul> <li>Install <code>curl</code> or <code>wget</code></li> </ul> <p><code>console    sudo apt install curl</code></p> <p>or</p> <p><code>console   sudo apt install wget</code></p> <ul> <li>Install compiler:</li> <li> <p>Ubuntu or Debian</p> <p><code>console sudo apt install git gcc g++ make</code></p> </li> <li> <p>Fedora or Red Hat</p> <p><code>console sudo dnf install git gcc gcc-c++ make</code></p> </li> <li> <p>Download the installer using <code>curl</code> or <code>wget</code> or your favourite download program and run the script.</p> </li> </ul> <p>For eg:</p> <p><code>console   curl -L -O \"https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-$(uname)-$(uname -m).sh\"   bash Mambaforge-$(uname)-$(uname -m).sh</code></p> <p>or</p> <p><code>console   wget \"https://github.com/conda-forge/miniforge/releases/latest/download/Mambaforge-$(uname)-$(uname -m).sh\"   bash Mambaforge-$(uname)-$(uname -m).sh</code></p> <ul> <li>Clone T3's repository by typing the following command in the   desired folder (e.g., under ~/Code/):</li> </ul> <p><code>console   git clone https://github.com/ReactionMechanismGenerator/T3.git</code></p>"},{"location":"installation/#setting-up-path","title":"Setting up Path","text":"<ul> <li>To set up T3 to your local path in .bashrc, you have two options:</li> </ul>"},{"location":"installation/#option-1","title":"Option 1","text":"<p>Terminal Command (NOTE: Make sure to change \"~/Path/to/T3/\" accordingly\"):</p> <p><code>console   echo 'PYTHONPATH=$PYTHONPATH:~/Path/to/T3/' &gt;&gt; ~/.bashrc</code></p>"},{"location":"installation/#option-2","title":"Option 2","text":"<p>Editing .bashrc directly (NOTE: Make sure to change \"~/Path/to/T3/\" accordingly\"):</p> <ul> <li>In terminal, enter the command:</li> </ul> <p><code>console   gedit ~/.bashrc</code></p> <ul> <li>Then in the opened file, on a new line, enter the following:</li> </ul> <p><code>text   export PYTHONPATH=$PYTHONPATH:~/Path/to/T3/</code></p>"},{"location":"installation/#install-dependencies","title":"Install dependencies","text":"<p>T3 requires RMG-Py, RMG-databse and ARC to function correctly. In order to install the necessary dependencies, you can follow either option below.</p>"},{"location":"installation/#option-1_1","title":"Option 1","text":"<ul> <li> <p>Navigate to the T3 folder, depending on where you cloned it to.</p> </li> <li> <p>Open a terminal in the T3 folder, and type the following:</p> </li> </ul> <p><code>console   make install</code></p> <p>Note: This can take some time to finish.</p> <ul> <li>You have now installed all the required dependencies.</li> </ul>"},{"location":"installation/#option-2_1","title":"Option 2:","text":"<ul> <li>Install the latest versions of RMG-Py and the RMG-database on the same machine where T3 is installed. Follow the instructions on RMG's Documentation.</li> <li> <p>Make sure to install RMG's developer version which includes important recent features. Note that the installation instructions suggest Anaconda, but Mambaforge can be used in it's place.</p> </li> <li> <p>Be sure to add RMG-Py to your PATH and PYTHONPATH as explained in the instructions.</p> </li> <li> <p>Install the latest version of ARC on the same machine where T3 is installed.   Follow the instructions on ARC's documentation</p> </li> <li> <p>Make sure to add ARC to your PATH and PYTHONPATH, as well as to define your servers as explained in ARC's documentation.</p> </li> <li> <p>Create the Anaconda/Mambaforge environment for T3 by executing the following command in the T3 folder:</p> </li> </ul> <pre><code>$ mamba env create -f environment.yml\n\nINFO:     Collecting package metadata (repodata.json): done\nINFO:     Solving environment: done\nINFO:     \nINFO:     Downloading and Extracting Packages\nINFO:     ...\nINFO:     Preparing transaction: done\nINFO:     Verifying transaction: done\nINFO:     Executing transaction: done\nINFO:     #\nINFO:     # To activate this environment, use\nINFO:     #\nINFO:     #     $ conda activate t3_env\nINFO:     #\nINFO:     # To deactivate an active environment, use\nINFO:     #\nINFO:     #     $ conda deactivate\n</code></pre> <ul> <li> <p>Activate the T3 environment every time before running T3:</p> <p><code>console conda activate t3_env</code></p> </li> </ul>"},{"location":"installation/#add-t3-aliases-to-your-bashrc","title":"Add T3 aliases to your .bashrc","text":"<p>Some optional yet convenient aliases are listed below (make sure to change \"/Path/to/T3/\" accordingly). Add these to your <code>.bashrc</code> file, which can be edited by typing, e.g., <code>nano ~/.bashrc</code>:</p> <pre><code>export t3_path=$HOME`/Path/to/T3'\nalias t3e='source activate t3_env'\nalias t3='python $t3_path/T3.py input.yml'\nalias t3code='cd $t3_path'\n</code></pre> <p>Then, after sourcing <code>.bashrc</code> or restarting the terminal, simply typing <code>t3e</code> will activate the environment, typing <code>t3code</code> will change the directory into the T3 repository, and finally typing <code>t3</code> from any folder with a valid T3 input file will execute T3 in that folder.</p>"},{"location":"installation/#updating-t3","title":"Updating T3","text":"<p>The T3 repository is being updated frequently. Make sure to update your instance of T3 to enjoy new features and get recent bug fixes. To get the most recent developer version, execute the following commands (make sure to change <code>~/Path/to/T3/</code> accordingly:</p> <pre><code>cd ~/Path/to/T3/\ngit fetch origin\ngit pull origin main\n</code></pre> <p>The above will update your main branch of T3.</p>"},{"location":"licence/","title":"Licence","text":"<p>T3 is distributed free of charge under the MIT license.</p> <p>MIT License</p> <p>Copyright (c) 2019-2020 Dana Research Group</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"output/","title":"Output","text":"<p>After running a Project, the local Project folder will contain the following directory tree (bold represents folders, italics represents files):</p> <ul> <li>t3.log: Details of all project execution procedures.</li> <li>iteration_x:<ul> <li>RMG:<ul> <li>input.py: The RMG input file for iteration x (automatically written by T3)</li> <li>RMG.log: The RMG log file for iteration x.</li> <li>Additional RMG files and folders</li> </ul> </li> <li>ARC:<ul> <li>restart.yml: The ARC restart file for iteration x.</li> <li>arc.log: The ARC log file for iteration x.</li> <li>calcs: All spawned jobs sorted by species name (including transition states).</li> <li>output: Additional ARC output files and folders.</li> </ul> </li> </ul> </li> </ul>"},{"location":"release/","title":"Release notes","text":""},{"location":"release/#t3-010","title":"T3 0.1.0","text":"<p>This is the first version of T3.</p>"},{"location":"release/#version-style","title":"Version style","text":"<p>T3 uses Semantic Versioning</p>"},{"location":"running/","title":"Running T3","text":""},{"location":"running/#general","title":"General","text":"<p>Executing T3 can be done via two ways:</p> <ul> <li>using an input file, or</li> <li>using the Python API</li> </ul> <p>Other than subtle differences described here, both approaches are equivalent as they can define the same parameters which will be processed via the same routines.</p> <p>Note</p> <p>Most examples in these documentation pages are in a Python API format rather than a YAML input file format.</p> <p>T3 also has a function for writing a corresponding YAML input file after defining parameters via the API, see the How-to guides for more details.</p>"},{"location":"running/#activate-the-environment","title":"Activate the environment","text":"<p>To use T3, first activate the T3 environment. Type either:</p> <pre><code>conda activate t3_env\n</code></pre> <p>or, if you have set up the recommended aliases, simply type:</p> <pre><code>t3e\n</code></pre>"},{"location":"running/#arguments","title":"Arguments","text":"<p>T3 has three minor arguments (<code>project</code>, <code>project_directory</code>, and <code>verbose</code>) and three primary arguments (<code>t3</code>, <code>rmg</code>, and <code>qm</code>).</p> <p>The <code>project</code> argument is required. It is a string representing the T3 project name.</p> <p>The <code>project_directory</code> argument is optional. It is a string representing the path to the local project directory where all the project files are stored. If not specified, it will be set to the folder in which the input file is located if T3 is being executed using an input file, or to a respective subfolder with the project's name under the <code>Projects</code> folder in the T3 repository.</p> <p>The <code>verbose</code> argument is optional. It is an integer representing the logging level used by T3. Allowed values are: <code>10</code>: debug level (very verbose), <code>20</code>: info level (default), <code>30</code>: warnings and errors only, <code>40</code>: errors only. Pass <code>None</code> to this argument to avoid saving a log file. </p> <p>The primary arguments specify various options for the different respective packages (T3, RMG, and QM which currently only supports ARC). Of these three, only the <code>rmg</code> argument is required. The <code>qm</code> argument must be specified if QM-based model refinement is desired (in most cases it is!). The <code>t3</code> argument contains optional T3-related directives and should commonly be specified.</p> <p>The RMG arguments in T3 are written in an underscore_lower_case (snake_case) syntax, while many are in a camelCase syntax in RMG. A few RMG arguments have different names altogether in T3. These arguments are:</p> <ul> <li><code>kinetics_libraries</code>: In the RMG database block, the <code>kinetics_libraries</code> argument   replaces the legacy RMG <code>reactionLibraries</code> argument.</li> <li><code>core_tolerance</code>: In the RMG model block, the <code>core_tolerance</code> argument   replaces the legacy RMG <code>toleranceMoveToCore</code> argument. See the   How-to guides for more details.</li> <li><code>conditions_per_iteration</code>: In the RMG reactors block, the <code>conditions_per_iteration</code> argument   replaces the legacy RMG <code>nSims</code> argument.</li> <li>Species definitions are different than in RMG, see the   How-to guides for more details.</li> <li>Reactors definitions are different than in RMG, see the   How-to guides for more details.</li> </ul> <p>Note</p> <p>Some of the RMG default values have been changed in T3, see the  schema for details. <p>Use the below reference guide to learn more about these arguments.</p>"},{"location":"running/#reference-guide","title":"Reference guide","text":"<p>T3 has several types of reference guides:</p> <ul> <li>The tutorials are a great place to start with,   and provide an excellent basic reference guide. In T3's tutorials you can find   complete, functioning, and worked-out examples with explanations.</li> <li>The    commented input file in T3's examples shows all available input arguments along with a brief explanation.</li> <li>A    pydentic schema is used to validate the input file,   and could also be used as a reference for the various allowed arguments.</li> </ul>"},{"location":"running/#where-next","title":"Where next?","text":"<p>New users should start learning how to use T3 by reading and executing the tutorials.</p> <p>For advanced features and specific examples for solving complex problems, see the  how-to guides. </p>"},{"location":"tutorials/1_no_qm/","title":"1. Simple system, no QM","text":"<p>This tutorial will guide you through setting up T3 to generate a detailed kinetic model for a relatively simple system, a H2/O2 flame. The model will consist of species and reactions for which thermodynamic properties and rate coefficients, respectively, are already known from the literature. It is an exercise in setting up T3 for a system for which no quantum mechanical (QM) calculations are executed.</p> <p>When using the API, the first directive is to import the main T3 object (this is not needed when using an input file):</p> <pre><code>from t3 import T3\nrmg_args = {'database': {'thermo_libraries': ['primaryThermoLibrary',\n                                              'BurkeH2O2'],\n                         'kinetics_libraries': ['BurkeH2O2inN2']},\n            'species': [{'label': 'H2',\n                         'smiles': '[H][H]',\n                         'concentration': 0.67},\n                        {'label': 'O2',\n                         'smiles': '[O][O]',\n                         'concentration': 0.33}],\n            'reactors': [{'type': 'gas batch constant T P',\n                          'T': 1000,\n                          'P': 1,\n                          'termination_conversion': {'H2': 0.9},\n                          'termination_time': [5, 's']}],\n            'model': {'core_tolerance': [0.01, 0.001]}}\n\nt3_object = T3(project='T3_tutorial_1',\n               rmg=rmg_args)\n\nt3_object.execute()\n</code></pre> <p>(This script is complete, it should run \"as is\")</p> <p>Next we'll define arguments related to RMG. This argument is a Python dictionary which will be passed to the <code>rmg</code> argument of the <code>T3</code> object imported above. You can name this argument with any legal Python name, here we use <code>rmg_args</code>. This is the only required primary argument -- this simple example does not make use of the additional primary arguments, <code>t3</code> and <code>qm</code>.</p> <pre><code>from t3 import T3\n\nrmg_args = {'database': {'thermo_libraries': ['primaryThermoLibrary',\n'BurkeH2O2'],\n'kinetics_libraries': ['BurkeH2O2inN2']},\n'species': [{'label': 'H2',\n'smiles': '[H][H]',\n'concentration': 0.67},\n{'label': 'O2',\n'smiles': '[O][O]',\n'concentration': 0.33}],\n'reactors': [{'type': 'gas batch constant T P',\n'T': 1000,\n'P': 1,\n'termination_conversion': {'H2': 0.9},\n'termination_time': [5, 's']}],\n'model': {'core_tolerance': [0.01, 0.001]}}\nt3_object = T3(project='T3_tutorial_1',\n               rmg=rmg_args)\n\nt3_object.execute()\n</code></pre> <p>Here, the <code>rmg_args</code> argument defines the database libraries to be used by RMG, the chemical species with respective structure and concentration, the reactor type, conditions and termination criteria, and the RMG core tolerances to be used throughout the different T3 iterations.</p> <p>Note</p> <p>The RMG arguments in T3 generally correspond to arguments used by the legacy RMG input file. Users should refer to the  RMG documentation for detailed explanations of all possible arguments. This tutorial, though, manages to capture all major syntax differences users should be aware of when defining the RMG arguments in T3:</p> <ol> <li>RMG arguments are currently in camelCase style (e.g., <code>thermoLibraries</code>), whereas the respective    arguments in T3 are in lower_case_underscore style (e.g., <code>thermo_libraries</code>).</li> <li>Species definitions in T3 are more flexible, see the    how-to guides for more details.</li> <li>Reactor types were re-named for clarity, see the    how-to guides for more details.</li> <li><code>core_tolerance</code> is a list of the RMG <code>toleranceMoveToCore</code> argument to use per T3 iteration.    If the number of iterations is larger than the length of <code>core_tolerance</code>, the last entry will be used.    The `core_tolerance`` argument can also be given as flot, in which case it will be treated as a onc-entry list.</li> <li>Minor: RMG uses the notation <code>reactionLibraries</code> while T3 uses <code>kinetics_libraries</code>.</li> </ol> <p>Next, we create the <code>T3</code> object with all desired arguments. Here, only the two required arguments, <code>project</code> and <code>rmg</code> are given.</p> <pre><code>from t3 import T3\n\nrmg_args = {'database': {'thermo_libraries': ['primaryThermoLibrary',\n                                              'BurkeH2O2'],\n                         'kinetics_libraries': ['BurkeH2O2inN2']},\n            'species': [{'label': 'H2',\n                         'smiles': '[H][H]',\n                         'concentration': 0.67},\n                        {'label': 'O2',\n                         'smiles': '[O][O]',\n                         'concentration': 0.33}],\n            'reactors': [{'type': 'gas batch constant T P',\n                          'T': 1000,\n                          'P': 1,\n                          'termination_conversion': {'H2': 0.9},\n                          'termination_time': [5, 's']}],\n            'model': {'core_tolerance': [0.01, 0.001]}}\n\nt3_object = T3(project='T3_tutorial_1',\nrmg=rmg_args)\nt3_object.execute()\n</code></pre> <p>Finally, we call the <code>execute()</code> method of <code>T3</code>.</p> <pre><code>from t3 import T3\n\nrmg_args = {'database': {'thermo_libraries': ['primaryThermoLibrary',\n                                              'BurkeH2O2'],\n                         'kinetics_libraries': ['BurkeH2O2inN2']},\n            'species': [{'label': 'H2',\n                         'smiles': '[H][H]',\n                         'concentration': 0.67},\n                        {'label': 'O2',\n                         'smiles': '[O][O]',\n                         'concentration': 0.33}],\n            'reactors': [{'type': 'gas batch constant T P',\n                          'T': 1000,\n                          'P': 1,\n                          'termination_conversion': {'H2': 0.9},\n                          'termination_time': [5, 's']}],\n            'model': {'core_tolerance': [0.01, 0.001]}}\n\nt3_object = T3(project='T3_tutorial_1',\n               rmg=rmg_args)\n\nt3_object.execute()\n</code></pre> <p>Note that the corresponding YAML input file for this tutorial would be:</p> <pre><code>project: T3_tutorial_1\nrmg:\ndatabase:\nkinetics_libraries:\n- BurkeH2O2inN2\nthermo_libraries:\n- primaryThermoLibrary\n- BurkeH2O2\nmodel:\ncore_tolerance:\n- 0.01\n- 0.001\nreactors:\n- P: 1.0\nT: 1000.0\ntermination_conversion:\nH2: 0.9\ntermination_time:\n- 5\n- 's'\ntype: gas batch constant T P\nspecies:\n- concentration: 0.67\nlabel: H2\nsmiles: '[H][H]'\n- concentration: 0.33\nlabel: O2\nsmiles: '[O][O]'\n</code></pre>"},{"location":"tutorials/2_adding_simulate_adapter/","title":"2. Adding a Simulate Adapter","text":"<p>This tutorial demonstrates how to create a new simulate adapter for T3 to use when simulating a mechanism. The currently implemented Cantera, RMG, and RMS adapters provide good examples for this process,  though this tutorial explains the steps in more detail by walking through each piece of the code block below.  First, create a file under <code>T3/t3/simulate/</code> where we will write the new simulate adapter class. Next, add the required imports as shown below. Additional packages may be needed depending on the task, but at a minimum, these are required.</p> <pre><code>from t3.logger import Logger\nfrom t3.simulate.adapter import SimulateAdapter\nfrom t3.simulate.factory import register_simulate_adapter\nclass NewSimulator(SimulateAdapter):\n\"\"\"\n    Briefly summarize what conditions and/or assumptions are used in this simulator.\n\n    Args:\n        t3 (dict): The T3.t3 attribute, which is a dictionary containing the t3 block from the input yaml or API.\n        rmg (dict): The T3.rmg attribute, which is a dictionary containing the rmg block from the input yaml or API.\n        paths (dict): The T3.paths attribute, which is a dictionary containing relevant paths.\n        logger (Logger): Instance of T3's Logger class.\n        atol (float): The absolute tolerance used when integrating.\n        rtol (float): The relative tolerance used when integrating.\n        observable_list (Optional[list]): Species used for SA. Entries are species labels as strings. Example: ['OH']\n        sa_atol (float, optional): The absolute tolerance used when performing sensitivity analysis.\n        sa_atol (float, optional): The relative tolerance used when performing sensitivity analysis.\n        global_observables (Optional[List[str]]): List of global observables ['IgD', 'ESR', 'SL'] used by Cantera adapters.\n\n    Attributes:\n        &lt;varies by class&gt; \n    \"\"\"\n\n    def __init__(self,\n                 t3: dict,\n                 rmg: dict,\n                 paths: dict,\n                 logger: Type[Logger],\n                 atol: float = 1e-16,\n                 rtol: float = 1e-8,\n                 observable_list: Optional[list] = None,\n                 sa_atol: float = 1e-6,\n                 sa_rtol: float = 1e-4,\n                 global_observables: Optional[Type[List[str]]] = None\n                 ):\n\n        # initialize attributes\n        self.t3 = t3\n        self.rmg = rmg\n        self.paths = paths\n        self.logger = logger\n        self.atol = atol\n        self.rtol = rtol\n        self.observable_list = observable_list or list()\n        self.sa_atol = sa_atol\n        self.sa_rtol = sa_rtol\n        self.global_observables = global_observables\n\n        # run any additional setup required by the class\n        self.set_up()\n\n\n    def set_up(self):\n\"\"\"\n        Set up the class, possibly by reading an input file, initializing values, and/or setting up the domain.\n        \"\"\"\n        &lt;Implement code here&gt;    \n\n\n    def simulate(self):\n\"\"\"\n        Simulate a job to obtain species profiles. Run sensitivity analysis if requested.\n        \"\"\"\n        &lt;Implement code here&gt;\n\n\n    def get_sa_coefficients(self):\n\"\"\"\n        Obtain the sensitivity analysis coefficients.\n\n        Returns:\n             sa_dict (dict): a SA dictionary, whose structure is given in the docstring for T3/t3/main.py\n        \"\"\"\n        &lt;Implement code here&gt;\n\n\n    def get_idt_by_T(self):\n\"\"\"\n        Finds the ignition point by approximating dT/dt as a first order forward difference\n        and then finds the point of maximum slope.\n\n        Returns:\n            idt_dict (dict): Dictionary whose keys include 'idt' and 'idt_index' and whose values are lists of\n                             the ignition delay time in seconds and index at which idt occurs respectively.\n        \"\"\"\n        &lt;Implement code here&gt;\n\n\n\nregister_simulate_adapter(\"NewSimulator\", NewSimulator)\n</code></pre> <p>The new class must inherit from the abstract adapter class in <code>T3/t3/simulate/adapter.py</code>. All simulate adapters accept the same arguments, allowing them to be used in a standardized way. Thus, the <code>Args</code> section in the docstring and the <code>__init__</code> method will be constant for all adapters.</p> <pre><code>from t3.logger import Logger\nfrom t3.simulate.adapter import SimulateAdapter\nfrom t3.simulate.factory import register_simulate_adapter\n\nclass NewSimulator(SimulateAdapter):\n\"\"\"\n    Briefly summarize what conditions and/or assumptions are used in this simulator.\n    Args:\n        t3 (dict): The T3.t3 attribute, which is a dictionary containing the t3 block from the input yaml or API.\n        rmg (dict): The T3.rmg attribute, which is a dictionary containing the rmg block from the input yaml or API.\n        paths (dict): The T3.paths attribute, which is a dictionary containing relevant paths.\n        logger (Logger): Instance of T3's Logger class.\n        atol (float): The absolute tolerance used when integrating.\n        rtol (float): The relative tolerance used when integrating.\n        observable_list (Optional[list]): Species used for SA. Entries are species labels as strings. Example: ['OH']\n        sa_atol (float, optional): The absolute tolerance used when performing sensitivity analysis.\n        sa_atol (float, optional): The relative tolerance used when performing sensitivity analysis.\n        global_observables (Optional[List[str]]): List of global observables ['IgD', 'ESR', 'SL'] used by Cantera adapters.\n    Attributes:\n        &lt;varies by class&gt; \n    \"\"\"\ndef __init__(self,\nt3: dict,\nrmg: dict,\npaths: dict,\nlogger: Type[Logger],\natol: float = 1e-16,\nrtol: float = 1e-8,\nobservable_list: Optional[list] = None,\nsa_atol: float = 1e-6,\nsa_rtol: float = 1e-4,\nglobal_observables: Optional[Type[List[str]]] = None\n):\n# initialize attributes\nself.t3 = t3\nself.rmg = rmg\nself.paths = paths\nself.logger = logger\nself.atol = atol\nself.rtol = rtol\nself.observable_list = observable_list or list()\nself.sa_atol = sa_atol\nself.sa_rtol = sa_rtol\nself.global_observables = global_observables\n# run any additional setup required by the class\nself.set_up()\ndef set_up(self):\n\"\"\"\n        Set up the class, possibly by reading an input file, initializing values, and/or setting up the domain.\n        \"\"\"\n        &lt;Implement code here&gt;    \n\n\n    def simulate(self):\n\"\"\"\n        Simulate a job to obtain species profiles. Run sensitivity analysis if requested.\n        \"\"\"\n        &lt;Implement code here&gt;\n\n\n    def get_sa_coefficients(self):\n\"\"\"\n        Obtain the sensitivity analysis coefficients.\n\n        Returns:\n             sa_dict (dict): a SA dictionary, whose structure is given in the docstring for T3/t3/main.py\n        \"\"\"\n        &lt;Implement code here&gt;\n\n\n    def get_idt_by_T(self):\n\"\"\"\n        Finds the ignition point by approximating dT/dt as a first order forward difference\n        and then finds the point of maximum slope.\n\n        Returns:\n            idt_dict (dict): Dictionary whose keys include 'idt' and 'idt_index' and whose values are lists of\n                             the ignition delay time in seconds and index at which idt occurs respectively.\n        \"\"\"\n        &lt;Implement code here&gt;\n\n\nregister_simulate_adapter(\"NewSimulator\", NewSimulator)\n</code></pre> <p>The next step is to implement the following methods that were inherited by the abstract class: <code>set_up()</code>, <code>simulate()</code>, <code>get_sa_coefficients()</code>, and  <code>get_idt_by_T()</code>. These methods are present in all simulators, and   if they return anything, do so in a standard format. This standardizes the use of different simulators, making it   easy for the user to simulate their mechanism with different adapters. </p> <pre><code>from t3.logger import Logger\nfrom t3.simulate.adapter import SimulateAdapter\nfrom t3.simulate.factory import register_simulate_adapter\n\nclass NewSimulator(SimulateAdapter):\n\"\"\"\n    Briefly summarize what conditions and/or assumptions are used in this simulator.\n\n    Args:\n        t3 (dict): The T3.t3 attribute, which is a dictionary containing the t3 block from the input yaml or API.\n        rmg (dict): The T3.rmg attribute, which is a dictionary containing the rmg block from the input yaml or API.\n        paths (dict): The T3.paths attribute, which is a dictionary containing relevant paths.\n        logger (Logger): Instance of T3's Logger class.\n        atol (float): The absolute tolerance used when integrating.\n        rtol (float): The relative tolerance used when integrating.\n        observable_list (Optional[list]): Species used for SA. Entries are species labels as strings. Example: ['OH']\n        sa_atol (float, optional): The absolute tolerance used when performing sensitivity analysis.\n        sa_atol (float, optional): The relative tolerance used when performing sensitivity analysis.\n        global_observables (Optional[List[str]]): List of global observables ['IgD', 'ESR', 'SL'] used by Cantera adapters.\n\n    Attributes:\n        &lt;varies by class&gt; \n    \"\"\"\n\n    def __init__(self,\n                 t3: dict,\n                 rmg: dict,\n                 paths: dict,\n                 logger: Type[Logger],\n                 atol: float = 1e-16,\n                 rtol: float = 1e-8,\n                 observable_list: Optional[list] = None,\n                 sa_atol: float = 1e-6,\n                 sa_rtol: float = 1e-4,\n                 global_observables: Optional[Type[List[str]]] = None\n                 ):\n\n        # initialize attributes\n        self.t3 = t3\n        self.rmg = rmg\n        self.paths = paths\n        self.logger = logger\n        self.atol = atol\n        self.rtol = rtol\n        self.observable_list = observable_list or list()\n        self.sa_atol = sa_atol\n        self.sa_rtol = sa_rtol\n        self.global_observables = global_observables\n\n        # run any additional setup required by the class\n        self.set_up()\n\n\ndef set_up(self):\n\"\"\"\n        Set up the class, possibly by reading an input file, initializing values, and/or setting up the domain.\n        \"\"\"\n&lt;Implement code here&gt;    \ndef simulate(self):\n\"\"\"\n        Simulate a job to obtain species profiles. Run sensitivity analysis if requested.\n        \"\"\"\n&lt;Implement code here&gt;\ndef get_sa_coefficients(self):\n\"\"\"\n        Obtain the sensitivity analysis coefficients.\n        Returns:\n             sa_dict (dict): a SA dictionary, whose structure is given in the docstring for T3/t3/main.py\n        \"\"\"\n&lt;Implement code here&gt;\ndef get_idt_by_T(self):\n\"\"\"\n        Finds the ignition point by approximating dT/dt as a first order forward difference\n        and then finds the point of maximum slope.\n        Returns:\n            idt_dict (dict): Dictionary whose keys include 'idt' and 'idt_index' and whose values are lists of\n                             the ignition delay time in seconds and index at which idt occurs respectively.\n        \"\"\"\n&lt;Implement code here&gt;\n\n\n\nregister_simulate_adapter(\"NewSimulator\", NewSimulator)\n</code></pre> <p>Finally, register the adapter with the factory at the bottom of the file.  Also, initialize the simulator by importing it in <code>T3/t3/simulate/__init__.py</code>.</p> <pre><code>from t3.logger import Logger\nfrom t3.simulate.adapter import SimulateAdapter\nfrom t3.simulate.factory import register_simulate_adapter\n\nclass NewSimulator(SimulateAdapter):\n\"\"\"\n    Briefly summarize what conditions and/or assumptions are used in this simulator.\n\n    Args:\n        t3 (dict): The T3.t3 attribute, which is a dictionary containing the t3 block from the input yaml or API.\n        rmg (dict): The T3.rmg attribute, which is a dictionary containing the rmg block from the input yaml or API.\n        paths (dict): The T3.paths attribute, which is a dictionary containing relevant paths.\n        logger (Logger): Instance of T3's Logger class.\n        atol (float): The absolute tolerance used when integrating.\n        rtol (float): The relative tolerance used when integrating.\n        observable_list (Optional[list]): Species used for SA. Entries are species labels as strings. Example: ['OH']\n        sa_atol (float, optional): The absolute tolerance used when performing sensitivity analysis.\n        sa_atol (float, optional): The relative tolerance used when performing sensitivity analysis.\n        global_observables (Optional[List[str]]): List of global observables ['IgD', 'ESR', 'SL'] used by Cantera adapters.\n\n    Attributes:\n        &lt;varies by class&gt; \n    \"\"\"\n\n    def __init__(self,\n                 t3: dict,\n                 rmg: dict,\n                 paths: dict,\n                 logger: Type[Logger],\n                 atol: float = 1e-16,\n                 rtol: float = 1e-8,\n                 observable_list: Optional[list] = None,\n                 sa_atol: float = 1e-6,\n                 sa_rtol: float = 1e-4,\n                 global_observables: Optional[Type[List[str]]] = None\n                 ):\n\n        # initialize attributes\n        self.t3 = t3\n        self.rmg = rmg\n        self.paths = paths\n        self.logger = logger\n        self.atol = atol\n        self.rtol = rtol\n        self.observable_list = observable_list or list()\n        self.sa_atol = sa_atol\n        self.sa_rtol = sa_rtol\n        self.global_observables = global_observables\n\n        # run any additional setup required by the class\n        self.set_up()\n\n\n    def set_up(self):\n\"\"\"\n        Set up the class, possibly by reading an input file, initializing values, and/or setting up the domain.\n        \"\"\"\n        &lt;Implement code here&gt;    \n\n\n    def simulate(self):\n\"\"\"\n        Simulate a job to obtain species profiles. Run sensitivity analysis if requested.\n        \"\"\"\n        &lt;Implement code here&gt;\n\n\n    def get_sa_coefficients(self):\n\"\"\"\n        Obtain the sensitivity analysis coefficients.\n\n        Returns:\n             sa_dict (dict): a SA dictionary, whose structure is given in the docstring for T3/t3/main.py\n        \"\"\"\n        &lt;Implement code here&gt;\n\n\n    def get_idt_by_T(self):\n\"\"\"\n        Finds the ignition point by approximating dT/dt as a first order forward difference\n        and then finds the point of maximum slope.\n\n        Returns:\n            idt_dict (dict): Dictionary whose keys include 'idt' and 'idt_index' and whose values are lists of\n                             the ignition delay time in seconds and index at which idt occurs respectively.\n        \"\"\"\n&lt;Implement code here&gt;\nregister_simulate_adapter(\"NewSimulator\", NewSimulator)\n</code></pre>"}]}