"""
t3 utils libraries module
for working with RMG thermo and kinetics libraries
"""

import datetime
import os
import shutil
import time
from collections import Counter

from typing import TYPE_CHECKING, Dict, List, Optional, Union

from rmgpy.data.kinetics import KineticsLibrary
from rmgpy.data.thermo import ThermoLibrary
from rmgpy.kinetics import Arrhenius, KineticsData
from rmgpy.kinetics.chebyshev import Chebyshev
from rmgpy.reaction import Reaction
from rmgpy.thermo import NASAPolynomial, NASA, ThermoData, Wilhoit
from rmgpy.species import Species

if TYPE_CHECKING:
    from arc.reaction import ARCReaction
    from arc.species import ARCSpecies
    from t3.logger import Logger


THERMO_LOCAL_CONTEXT = {
    'ThermoData': ThermoData,
    'Wilhoit': Wilhoit,
    'NASAPolynomial': NASAPolynomial,
    'NASA': NASA,
}
KINETICS_LOCAL_CONTEXT = {
    'KineticsData': KineticsData,
    'Arrhenius': Arrhenius,
    'Chebyshev': Chebyshev, 
}


def add_to_rmg_libraries(library_name: str,
                         shared_library_name: str,
                         paths: Dict[str, str],
                         logger: 'Logger',
                         ):
    """
    Creates RMG libraries in the RMG database repository if they don't already exist,
    and appends with the respective entries from the libraries generated by ARC.

    Args:
        library_name (str): The name of the RMG library.
        shared_library_name (str): The name of an RMG database library shared between T3 projects.
        paths (Dict[str, str]): T3's dictionary of paths.
        logger (Logger): Instance of T3's Logger class.
    """
    for token in ['thermo', 'kinetics']:
        arc_lib_path, t3_lib_path, shared_lib_path = \
            paths[f'ARC {token} lib'], paths[f'T3 {token} lib'], paths[f'shared T3 {token} lib']
        if token == 'thermo':
            local_context = THERMO_LOCAL_CONTEXT
        else:
            local_context = KINETICS_LOCAL_CONTEXT
        for to_lib_path, lib_name, race in zip([shared_lib_path, t3_lib_path],
                                               [library_name, shared_library_name],
                                               [True, False]):
            if os.path.isfile(arc_lib_path) and to_lib_path is not None and os.path.isfile(to_lib_path):
                append_to_rmg_library(library_name=lib_name,
                                      from_lib_path=arc_lib_path,
                                      to_lib_path=to_lib_path,
                                      local_context=local_context,
                                      lib_type=token,
                                      logger=logger,
                                      race=race,
                                      )
            else:
                # The destination library (T3's or the shared) doesn't exist. Just copy the library generated by ARC.
                if token == 'thermo':
                    if os.path.isfile(arc_lib_path) and to_lib_path is not None:
                        if not os.path.isdir(os.path.dirname(to_lib_path)):
                            os.makedirs(os.path.dirname(to_lib_path))
                        shutil.copy(arc_lib_path, to_lib_path)
                elif token == 'kinetics':
                    if os.path.isdir(arc_lib_path) and to_lib_path is not None:
                        if not os.path.isdir(to_lib_path):
                            os.makedirs(to_lib_path, exist_ok=True)
                        for file_name in ['reactions.py', 'dictionary.txt']:
                            src = os.path.join(arc_lib_path, file_name)
                            if os.path.isfile(src):
                                shutil.copy(src, os.path.join(to_lib_path, file_name))


def append_to_rmg_library(library_name: str,
                          from_lib_path: str,
                          to_lib_path: str,
                          local_context: dict,
                          lib_type: str,
                          logger: 'Logger',
                          race: bool = False,
                          ):
    """
    Append the entries from the ARC-generated library to an RMG library.

    Args:
        library_name (str): The name of the RMG library.
        from_lib_path (str): The path to the ARC-generated library.
        to_lib_path (str): The path to the RMG library to append to.
        local_context (dict): The local context to use when loading the libraries.
        lib_type (str): The type of the library (either 'thermo' or 'kinetics').
        logger (Logger): Instance of T3's Logger class.
        race (bool, optional): Whether to take measures to avoid a race condition when appending to the library.
    """
    race_path = os.path.join(os.path.dirname(to_lib_path), f'{library_name}.race')
    if race:
        race_free = check_race_condition(race_path)
        if not race_free:
            logger.error(f'Could not write to library {to_lib_path} due to a race condition.\n'
                         f'Check whether it is safe to delete the {race_path} file to continue.')
            return
    from_lib, to_lib = (ThermoLibrary(), ThermoLibrary()) if lib_type == 'thermo' \
        else (KineticsLibrary(), KineticsLibrary())
    to_lib.load(path=to_lib_path, local_context=local_context, global_context=dict())
    from_lib.load(path=from_lib_path, local_context=local_context, global_context=dict())
    from_description = from_lib.long_desc
    description_to_append = '\n'
    append = False
    for line in from_description.splitlines():
        if 'Overall time since project initiation' in line:
            append = False
        if append:
            description_to_append += line + '\n'
        if 'Considered the following' in line:
            append = True
    to_lib.long_desc += description_to_append
    for entry in from_lib.entries.values():
        to_lib = add_entry_to_library(entry=entry,
                                      to_lib=to_lib,
                                      lib_type=lib_type,
                                      library_name=library_name,
                                      logger=logger,
                                      )
    to_lib.save(path=to_lib_path)
    lift_race_condition(race_path)


def add_entry_to_library(entry,
                         to_lib: Union[ThermoLibrary, KineticsLibrary],
                         lib_type: str,
                         library_name: str,
                         logger: 'Logger',
                         ) -> Union[ThermoLibrary, KineticsLibrary]:
    """
    Add an entry to the RMG library if it's not already present.

    Args:
        entry: Entry object from the ARC-generated library.
        to_lib (Union[ThermoLibrary, KineticsLibrary]): RMG library object to append to.
        lib_type (str): Type of library ('thermo' or 'kinetics').
        library_name (str): Name of the target RMG library.
        logger (Logger): Logger instance.

    Returns:
        Union[ThermoLibrary, KineticsLibrary]: The updated RMG library with the new entry added.
    """
    skip_entry = False
    if lib_type == 'thermo':
        entry_species = Species(molecule=[entry.item])
        entry_species.generate_resonance_structures(keep_isomorphic=False, filter_structures=True)
        for existing_entry in to_lib.entries.values():
            if entry_species.is_isomorphic(existing_entry.item):
                if entry.label != existing_entry.label:
                    logger.warning(f"Not adding species {entry.label} to the {library_name} thermo library, "
                                   f"the species seems to already exist under the label {existing_entry.label}.")
                skip_entry = True
                break
    elif lib_type == 'kinetics':
        entry_reaction = Reaction(reactants=entry.item.reactants[:],
                                  products=entry.item.products[:],
                                  specific_collider=entry.item.specific_collider,
                                  kinetics=entry.data,
                                  duplicate=entry.item.duplicate,
                                  reversible=entry.item.reversible,
                                  allow_pdep_route=entry.item.allow_pdep_route,
                                  elementary_high_p=entry.item.elementary_high_p)
        for existing_entry in to_lib.entries.values():
            if entry_reaction.is_isomorphic(existing_entry.item):
                logger.warning(f"Not adding reaction {entry.label} to the {library_name} kinetics library, "
                               f"the reaction seems to already exist under the label {existing_entry.label}.")
                skip_entry = True
                break
    if not skip_entry:
        to_lib.entries[entry.label] = entry
    return to_lib


def check_race_condition(race_path: str,
                         ) -> bool:
    """
    Check for a race condition and avoid one by creating a race holder file.

    Args:
        race_path (str): The path to the race file to check.

    Returns:
        bool: Whether there is no race condition and T3 may continue (True) or an unavoidable race exists (False).
    """
    counter = 0
    while os.path.isfile(race_path):
        with open(race_path, 'r') as f:
            content = f.read()
            if content:
                creation_date = content.split(' ')[-1]
                creation_datetime = datetime.datetime.strptime(creation_date, "%H%M%S_%b%d_%Y")
                time_delta = datetime.datetime.now() - creation_datetime
                if time_delta.total_seconds() > 1000:
                    lift_race_condition(race_path)
                    return True
        counter += 1
        time.sleep(10)
        if counter > 1000:
            return False
    with open(race_path, 'w') as f:
        f.write(f'Race created at {datetime.datetime.now().strftime("%H%M%S_%b%d_%Y")}')
    return True


def lift_race_condition(race_path: str) -> None:
    """
    Lift the race condition by deleting the race holder file.

    Args:
        race_path (str): The path to the race file to check.
    """
    if os.path.isfile(race_path):
        os.remove(race_path)


def add_species_from_candidate_lib_to_t3_lib(species: 'ARCSpecies',
                                             source_library_path: str,
                                             shared_library_name: str,
                                             paths: Dict[str, str],
                                             logger: 'Logger',
                                             race: bool = True,
                                             ) -> bool:
    """
    Add a species to the T3 thermo library.

    Args:
        species ('ARCSpecies'): The species oto add to the T3 library.
        source_library_path (str): The path to the source library from which the species is added.
        shared_library_name (str): The name of an RMG database library shared between T3 projects.
        paths (Dict[str, str]): T3's dictionary of paths.
        logger (Logger): Instance of T3's Logger class.
        race (bool, optional): Whether to take measures to avoid a race condition when appending to the library.

    Returns:
        bool: True if the species was added successfully, False otherwise.
    """
    counter = 10
    sleep_time = 10
    while counter > 0:
        added = _add_species_from_candidate_lib_to_t3_lib(species=species,
                                                          source_library_path=source_library_path,
                                                          shared_library_name=shared_library_name,
                                                          paths=paths,
                                                          logger=logger,
                                                          race=race,
                                                          )
        if added is not None:
            return added
        logger.debug(f'Failed to add species {species.label} to the shared T3 thermo library {shared_library_name}. '
                       f'Retrying in {sleep_time} seconds...')
        time.sleep(sleep_time)
        counter -= 1
    logger.error(f'Failed to add species {species.label} to the shared T3 thermo library {shared_library_name} '
                 f'after multiple attempts.')
    return False


def _add_species_from_candidate_lib_to_t3_lib(species: 'ARCSpecies',
                                             source_library_path: str,
                                             shared_library_name: str,
                                             paths: Dict[str, str],
                                             logger: 'Logger',
                                             race: bool = True,
                                             ) -> Optional[bool]:
    """
    Add a species to the T3 thermo library.

    Args:
        species ('ARCSpecies'): The species oto add to the T3 library.
        source_library_path (str): The path to the source library from which the species is added.
        shared_library_name (str): The name of an RMG database library shared between T3 projects.
        paths (Dict[str, str]): T3's dictionary of paths.
        logger (Logger): Instance of T3's Logger class.
        race (bool, optional): Whether to take measures to avoid a race condition when appending to the library.

    Returns:
        bool: True if the species was added successfully, False if not. None if a race condition was met.
    """
    added = False
    to_lib_path = paths[f'shared T3 thermo lib']
    race_path = os.path.join(os.path.dirname(to_lib_path), f'{shared_library_name}.race')
    if race:
        race_free = check_race_condition(race_path)
        if not race_free:
            logger.error(f'Could not write to library {to_lib_path} due to a race condition.\n'
                         f'Check whether it is safe to delete the {race_path} file to continue.')
            return False
    from_lib, to_lib = ThermoLibrary(), ThermoLibrary()
    from_lib.load(path=source_library_path, local_context=THERMO_LOCAL_CONTEXT, global_context=dict())
    if os.path.isfile(to_lib_path):
        to_lib.load(path=to_lib_path, local_context=THERMO_LOCAL_CONTEXT, global_context=dict())
    for entry in from_lib.entries.values():
        if species.is_isomorphic(entry.item):
            to_lib = add_entry_to_library(entry=entry,
                         to_lib=to_lib,
                         lib_type='thermo',
                         library_name=shared_library_name,
                         logger=logger,
                         )
            added = True
            break
    if added:
        to_lib.save(path=to_lib_path)
        logger.info(f'Added species {species.label} from candidate library to the shared T3 thermo library.')
    lift_race_condition(race_path)
    return added


def add_reaction_from_candidate_lib_to_t3_lib(reaction: 'ARCReaction',
                                              source_library_path: str,
                                              shared_library_name: str,
                                              paths: Dict[str, str],
                                              logger: 'Logger',
                                              race: bool = True,
                                              ) -> bool:
    """
    Add a reaction to the T3 kinetics library.

    Args:
        reaction ('ARCReaction'): The reaction to add to the T3 library.
        source_library_path (str): The path to the source library from which the species is added.
        shared_library_name (str): The name of an RMG database library shared between T3 projects.
        paths (Dict[str, str]): T3's dictionary of paths.
        logger (Logger): Instance of T3's Logger class.
        race (bool, optional): Whether to take measures to avoid a race condition when appending to the library.

    Returns:
        bool: True if the reaction was added successfully, False otherwise.
    """
    counter = 10
    sleep_time = 10
    while counter > 0:
        added = _add_reaction_from_candidate_lib_to_t3_lib(reaction=reaction,
                                                           source_library_path=source_library_path,
                                                           shared_library_name=shared_library_name,
                                                           paths=paths,
                                                           logger=logger,
                                                           race=race,
                                                           )
        if added is not None:
            return added
        logger.debug(f'Failed to add reaction {reaction.label} to the shared T3 kinetics library {shared_library_name}. '
                       f'Retrying in {sleep_time} seconds...')
        time.sleep(sleep_time)
        counter -= 1
    logger.error(f'Failed to add reaction {reaction.label} to the shared T3 kinetics library {shared_library_name} '
                 f'after multiple attempts.')
    return False


def _add_reaction_from_candidate_lib_to_t3_lib(reaction: 'ARCReaction',
                                               source_library_path: str,
                                               shared_library_name: str,
                                               paths: Dict[str, str],
                                               logger: 'Logger',
                                               race: bool = True,
                                               ) -> Optional[bool]:
    """
    Add a reaction to the T3 kinetics library.

    Args:
        reaction ('ARCReaction'): The reaction to add to the T3 library.
        source_library_path (str): The path to the source library from which the species is added.
        shared_library_name (str): The name of an RMG database library shared between T3 projects.
        paths (Dict[str, str]): T3's dictionary of paths.
        logger (Logger): Instance of T3's Logger class.
        race (bool, optional): Whether to take measures to avoid a race condition when appending to the library.

    Returns:
        bool: True if the reaction was added successfully, False if not. None if a race condition was met.
    """
    if os.path.isdir(source_library_path):
        source_library_path = os.path.join(source_library_path, 'reactions.py')
    added = False
    to_lib_path = paths[f'shared T3 kinetics lib']
    to_lib_rxns_path = os.path.join(to_lib_path, 'reactions.py')
    if not os.path.isdir(to_lib_path):
        os.makedirs(to_lib_path, exist_ok=True)
    race_path = os.path.join(os.path.dirname(to_lib_path), f'{shared_library_name}.race')
    if race:
        race_free = check_race_condition(race_path)
        if not race_free:
            logger.error(f'Could not write to library {to_lib_path} due to a race condition.\n'
                         f'Check whether it is safe to delete the {race_path} file to continue.')
            return False
    from_lib, to_lib = KineticsLibrary(), KineticsLibrary()
    from_lib.load(path=source_library_path, local_context=KINETICS_LOCAL_CONTEXT, global_context=dict())
    if os.path.isfile(to_lib_rxns_path):
        to_lib.load(path=to_lib_rxns_path, local_context=KINETICS_LOCAL_CONTEXT, global_context=dict())
    copied_rxn = None
    for entry in from_lib.entries.values():
        if is_reaction_isomorphic(reaction, entry.item):
            to_lib = add_entry_to_library(entry=entry,
                                          to_lib=to_lib,
                                          lib_type='kinetics',
                                          library_name=shared_library_name,
                                          logger=logger,
                                          )
            copied_rxn = entry.item
            added = True
            break
    # If the copied reaction is PDep, add the entire PES to the library.
    logger.info(f'++ Check for additional rxns on the same PES as {reaction.label} ++')
    if copied_rxn is not None:
        logger.warning(f'copied_rxn: {copied_rxn}, kinetics: {copied_rxn.kinetics if copied_rxn else None}, ')
        logger.info(f'!!! copied rxn type: {type(copied_rxn)}')
        logger.info(f'*** copied rxn index: {copied_rxn.index}, label: {copied_rxn.label}, degeneracy: {copied_rxn.degeneracy}, kinetics: {copied_rxn.kinetics}')
        logger.info(f'entry: {entry}, entry label: {entry.label}, entry item: {entry.item}')
    if copied_rxn is not None:
        pes_formula = get_rxn_composition(copied_rxn)
        logger.info(f'pes: {pes_formula}')
        for entry in from_lib.entries.values():
            if entry.item is not copied_rxn and \
                get_rxn_composition(entry.item) == pes_formula and \
                    (entry.item.kinetics.is_pdep() or copied_rxn.elementary_high_p):
                logger.error(f'Adding reaction {entry.label} to the shared T3 kinetics library '
                             f'because it is part of the same PES as {reaction.label}.')
                to_lib = add_entry_to_library(entry=entry,
                                              to_lib=to_lib,
                                              lib_type='kinetics',
                                              library_name=shared_library_name,
                                              logger=logger,
                                              )
    if added:
        to_lib.save(path=to_lib_rxns_path)
        logger.info(f'Added reaction {reaction.label} from candidate library to the shared T3 kinetics library.')
    lift_race_condition(race_path)
    return added


def is_species_list_isomorphic(arc_species_list: List['ARCSpecies'],
                               rmg_species_list: List[Union[Species, 'ARCSpecies']],
                               ) -> bool:
    """
    Check if two lists of species are isomorphic as multisets.

    This function checks whether each species in the ARC species list has a unique
    isomorphic match in the RMG species list, regardless of order.

    Args:
        arc_species_list (List[ARCSpecies]): A list of ARCSpecies.
        rmg_species_list (List[Union[Species, 'ARCSpecies']]): A list of RMG Species or ARCSpecies.

    Returns:
        bool: True if the two lists are isomorphic as multisets, False otherwise.
    """
    if len(arc_species_list) != len(rmg_species_list):
        return False

    used = [False] * len(rmg_species_list)

    def backtrack(i):
        if i == len(arc_species_list):
            return True
        for j, rmg_species in enumerate(rmg_species_list):
            if not used[j] and arc_species_list[i].is_isomorphic(rmg_species):
                used[j] = True
                if backtrack(i + 1):
                    return True
                used[j] = False
        return False

    return backtrack(0)


def is_reaction_isomorphic(reaction: 'ARCReaction',
                           rmg_reaction: Reaction,
                           ) -> bool:
    """
    Check if an ARC reaction is isomorphic to an RMG reaction.

    A reaction is considered isomorphic if either:
    - The reactants of the ARC reaction are isomorphic to the reactants of the RMG reaction,
      and the products are isomorphic to the products (in any order), or
    - The reactants of the ARC reaction are isomorphic to the products of the RMG reaction,
      and the products are isomorphic to the reactants (in any order).

    Args:
        reaction (ARCReaction): The ARC reaction to check.
        rmg_reaction (Reaction): The RMG reaction to check against.

    Returns:
        bool: True if the reactions are isomorphic, False otherwise.
    """
    rmg_reaction = rmg_reaction.copy()
    reactants, products = reaction.get_reactants_and_products(arc=True, return_copies=True)
    if is_species_list_isomorphic(reactants, rmg_reaction.reactants) and \
       is_species_list_isomorphic(products, rmg_reaction.products):
        return True
    if is_species_list_isomorphic(reactants, rmg_reaction.products) and \
       is_species_list_isomorphic(products, rmg_reaction.reactants):
        return True
    return False


def get_rxn_composition(reaction: Reaction) -> Dict[str, int]:
    """
    Get the composition (molecular formula) of the PES for a reaction.

    Args:
        reaction (Reaction): The reaction to get the PES molecular weight from.

    Returns:
        float: The molecular weight of the PES.
    """
    pes_composition = Counter(atom.element.symbol
                              for reactant in reaction.reactants
                              for atom in reactant.molecule[0].atoms)
    return dict(pes_composition)
